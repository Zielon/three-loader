{"version":3,"sources":["webpack://potree/webpack/universalModuleDefinition","webpack://potree/webpack/bootstrap","webpack://potree/external \"three\"","webpack://potree/./src/utils/binary-heap.js","webpack://potree/./src/materials/shaders/blur.vert","webpack://potree/./src/materials/shaders/blur.frag","webpack://potree/./src/materials/shaders/pointcloud.vert","webpack://potree/./src/materials/shaders/pointcloud.frag","webpack://potree/./src/workers/binary-decoder-worker.js","webpack://potree/./node_modules/worker-loader/dist/workers/InlineWorker.js","webpack://potree/./src/materials/clipping.ts","webpack://potree/./src/materials/enums.ts","webpack://potree/./src/materials/blur-material.ts","webpack://potree/./src/constants.ts","webpack://potree/./src/materials/classification.ts","webpack://potree/./src/materials/gradients/spectral.ts","webpack://potree/./src/materials/texture-generation.ts","webpack://potree/./src/point-attributes.ts","webpack://potree/./src/materials/point-cloud-material.ts","webpack://potree/./src/utils/bounds.ts","webpack://potree/./src/utils/utils.ts","webpack://potree/./src/point-cloud-octree-geometry-node.ts","webpack://potree/./src/point-cloud-octree-geometry.ts","webpack://potree/./src/point-cloud-octree-node.ts","webpack://potree/./src/point-cloud-tree.ts","webpack://potree/./src/utils/math.ts","webpack://potree/./src/point-cloud-octree.ts","webpack://potree/./src/features.ts","webpack://potree/./src/version.ts","webpack://potree/./src/loading/binary-loader.ts","webpack://potree/./src/loading/load-poc.ts","webpack://potree/./src/type-predicates.ts","webpack://potree/./src/utils/box3-helper.ts","webpack://potree/./src/utils/lru.ts","webpack://potree/./src/potree.ts","webpack://potree/./src/index.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","BinaryHeap","scoreFunction","this","content","push","element","bubbleUp","length","pop","result","end","sinkDown","remove","node","size","score","parentN","Math","floor","parent","elemScore","child2N","child1N","swap","child1","child1Score","child2","URL","webkitURL","url","blob","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","append","getBlob","e","Blob","Worker","createObjectURL","encodeURIComponent","Error","ClipMode","PointSizeType","PointShape","TreeType","PointOpacityType","PointColorType","BlurMaterial","_super","_this","apply","arguments","vertexShader","fragmentShader","uniforms","near","type","far","screenWidth","screenHeight","map","__extends","external_three_","DEFAULT_RGB_BRIGHTNESS","DEFAULT_RGB_CONTRAST","DEFAULT_RGB_GAMMA","DEFAULT_MAX_POINT_SIZE","DEFAULT_MIN_NODE_PIXEL_SIZE","DEFAULT_MIN_POINT_SIZE","DEFAULT_POINT_BUDGET","MAX_NUM_NODES_LOADING","DEFAULT_CLASSIFICATION","0","1","2","3","4","5","6","7","8","9","12","DEFAULT","SPECTRAL","generateDataTexture","width","height","color","data","Uint8Array","g","b","texture","needsUpdate","magFilter","generateGradientTexture","gradient","canvas","document","createElement","context","getContext","rect","ctxGradient","createLinearGradient","step","addColorStop","getHexString","fillStyle","fill","minFilter","generateClassificationTexture","classification","x","y","z","w","PointAttributeName","TREE_TYPE_DEFS","point_cloud_material_a","OCTREE","KDTREE","SIZE_TYPE_DEFS","point_cloud_material_b","FIXED","ATTENUATED","ADAPTIVE","OPACITY_DEFS","_c","SHAPE_DEFS","_d","SQUARE","CIRCLE","PARABOLOID","COLOR_DEFS","_e","RGB","COLOR","DEPTH","HEIGHT","INTENSITY","INTENSITY_GRADIENT","LOD","POINT_INDEX","CLASSIFICATION","RETURN_NUMBER","SOURCE","NORMAL","PHONG","RGB_HEIGHT","COMPOSITE","CLIP_MODE_DEFS","_f","DISABLED","CLIP_OUTSIDE","HIGHLIGHT_INSIDE","point_cloud_material_PointCloudMaterial","PointCloudMaterial","parameters","lights","fog","numClipBoxes","clipBoxes","_gradient","gradientTexture","_classification","classificationTexture","bbSize","makeUniform","blendDepthSupplement","blendHardness","classificationLUT","clipBoxCount","depthMap","diffuse","fov","heightMax","heightMin","intensityBrightness","intensityContrast","intensityGamma","intensityRange","isLeafNode","level","maxSize","minSize","octreeSize","opacity","pcIndex","rgbBrightness","rgbContrast","rgbGamma","spacing","toModel","transition","uColor","visibleNodes","visibleNodesTexture","vnStart","wClassification","wElevation","wIntensity","wReturnNumber","wRGB","wSourceID","opacityAttenuation","filterByNormalThreshold","useClipBox","weighted","pointColorType","pointSizeType","clipMode","useEDL","shape","treeType","pointOpacityType","useFilterByNormal","attributes","position","normal","intensity","returnNumber","numberOfReturns","pointSourceID","indices","tex","setUniform","getValid","defaultAttributeValues","vertexColors","updateShaderSource","point_cloud_material_extends","applyDefines","blending","transparent","depthTest","depthWrite","depthFunc","shaderSrc","parts","join","setClipBoxes","doUpdate","clipBoxesLength","clipBoxesArray","Float32Array","set","inverse","elements","isNaN","Infinity","copy","_i","_a","keys","clone","isEqual","undefined","_b","equals","recomputeClassification","getUniform","uObj","__decorate","uniform","requiresShaderUpdate","a","uniformName","requireSrcUpdate","target","propertyKey","fieldName","toString","POINT_ATTRIBUTE_TYPES","DATA_TYPE_DOUBLE","ordinal","DATA_TYPE_FLOAT","DATA_TYPE_INT8","DATA_TYPE_UINT8","DATA_TYPE_INT16","DATA_TYPE_UINT16","DATA_TYPE_INT32","DATA_TYPE_UINT32","DATA_TYPE_INT64","DATA_TYPE_UINT64","makePointAttribute","numElements","byteSize","RGBA_PACKED","COLOR_PACKED","POINT_ATTRIBUTES","POSITION_CARTESIAN","RGB_PACKED","NORMAL_FLOATS","FILLER_1B","FILLER","NORMAL_SPHEREMAPPED","NORMAL_OCT16","PointAttributes","pointAttributeNames","pointAttributeName","pointAttribute","add","hasColors","find","isColorAttribute","hasNormals","isNormalAttribute","computeTransformedBoundingBox","box","transform","setFromPoints","min","applyMatrix4","max","createChildAABB","aabb","index","subVectors","getIndexFromName","parseInt","charAt","byLevelAndIndex","na","nb","point_cloud_octree_geometry_node_PointCloudOctreeGeometryNode","PointCloudOctreeGeometryNode","pcoGeometry","boundingBox","id","idCount","hasChildren","children","mean","numPoints","geometry","loaded","loading","oneTimeDisposeHandlers","isTreeNode","isGeometryNode","tightBoundingBox","boundingSphere","getBoundingSphere","point_cloud_octree_geometry_node_extends","dispose","forEach","handler","getUrl","version","loader","pathParts","octreeDir","equalOrHigher","getHierarchyBaseUrl","upTo","getHierarchyUrl","addChild","child","traverse","cb","includeSelf","current","stack","load","canLoad","numNodesLoading","hierarchyStepSize","loadHierachyThenPoints","loadPoints","Promise","resolve","disposed","maxNumNodesLoading","then","xhrRequest","res","arrayBuffer","loadHierarchy","substr","numParts","path","slice","buffer","view","DataView","firstNodeData","getNodeData","decoded","offset","stackNodeData","shift","mask","byteLength","nodeData","nodes","Map","addNode","getUint8","getUint32","pco","parentName","substring","parentNode","pow","point_cloud_octree_geometry_PointCloudOctreeGeometry","PointCloudOctreeGeometry","pointAttributes","projection","addNodeLoadedCallback","callback","callbacks","clearNodeLoadedCallbacks","PointCloudOctreeNode","geometryNode","sceneNode","boundingBoxNode","point_cloud_octree_node_extends","PointCloudTree","point_cloud_tree_extends","initialized","clamp","helperVec3","point_cloud_octree_PointCloudOctree","PointCloudOctree","potree","material","maxLevel","minNodePixelSize","boundingBoxNodes","visibleGeometry","numVisiblePoints","showBoundingBox","visibleBounds","visibleNodeTextureOffsets","helperSphere","updateMatrix","initMaterial","point_cloud_octree_extends","updateMatrixWorld","getBoundingBoxWorld","matrixWorld","bWidth","clear","pickState","renderTarget","toTreeNode","frustumCulled","onBeforeRender","makeOnBeforeRender","_renderer","_scene","_camera","_geometry","materialUniforms","indexOf","uniformsNeedUpdate","updateVisibleBounds","bounds","expandByPoint","updateBoundingBoxes","bbRoot","getObjectByName","visibleBoxes","updateMaterial","camera","renderer","maxScale","scale","pixelRatio","getPixelRatio","PI","domElement","clientWidth","clientHeight","getSize","updateVisibilityTextureData","sort","offsetsToChild","Array","parentOffset","parentOffsetToChild","image","nodesOnRay","ray","rayClone","nodes_1","sphere","intersectsSphere","force","matrixAutoUpdate","matrixWorldNeedsUpdate","multiplyMatrices","matrix","hideDescendants","toHide","addVisibleChildren","objToHide","visible","obj","moveToOrigin","sub","getCenter","moveToGroundPlane","getVisibleExtent","pick","params","pickWndSize","pickWindowSize","ceil","getPickState","pickMaterial","tempNodes","tempNode","scene","autoUpdate","updatePickMaterial","updatePickRenderTarget","pixelPos","addVectors","direction","project","halfPickWndSize","setScissor","setScissorTest","state","buffers","depth","setTest","setMask","setBlending","setRenderTarget","render","pixels","readRenderTargetPixels","ibuffer","Uint32Array","Number","MAX_VALUE","hit","u","v","distance","pIndex","getPickPoint","point","points","values","addPositionToPickPoint","addNormalToPickPoint","itemSize","array","j","normalsArray","getInverse","transpose","datasetNormal","makePickRenderTarget","pickOutsideClipRegion","setSize","format","features_canvas","gl","FEATURES","SHADER_INTERPOLATION","hasExtension","hasMinVaryingVectors","SHADER_SPLATS","SHADER_EDL","precision","vsHighpFloat","getShaderPrecisionFormat","VERTEX_SHADER","HIGH_FLOAT","vsMediumpFloat","MEDIUM_FLOAT","fsHighpFloat","FRAGMENT_SHADER","fsMediumpFloat","highpAvailable","mediumpAvailable","getPrecision","ext","Boolean","getExtension","getParameter","MAX_VARYING_VECTORS","Version","versionMinor","vmLength","versionMajor","newerThan","binary_loader_BinaryLoader","BinaryLoader","workers","worker","terminate","getNodeUrl","parse","getWorker","onmessage","addBufferAttributes","attributeBuffers","addIndices","addNormalAttribute","fromArray","getTightBoundingBox","releaseWorker","message","toArray","postMessage","isAttribute","addAttribute","indicesAttribute","normalized","getAttribute","loadPOC","transformedUrl","json","lx","ly","lz","ux","uy","uz","getBoundingBoxes","hierarchy","loadRoot","name_1","loadRemainingHierarchy","box3_helper_Box3Helper","Box3Helper","Uint16Array","positions","setIndex","box3_helper_extends","LRUItem","next","previous","LRU","pointBudget","first","last","items","has","touch","item","touchExisting","addNew","delete","getLRUItem","freeMemory","disposeDescendants","QueueItem","pointCloudIndex","weight","potree_Potree","Potree","frustumMatrix","inverseWorldMatrix","cameraMatrix","_pointBudget","_rendererSize","features","lru","updateVisibilityStructures","pointClouds","frustums","cameraPositions","priorityQueue","binary_heap","pointCloud","inverseViewMatrix","matrixWorldInverse","worldMatrix","identity","multiply","projectionMatrix","setFromMatrix","setFromMatrixPosition","loadPointCloud","input","init","fetch","updatePointClouds","updateVisibility","queueItem","unloadedGeometry","loadedToGPUThisFrame","intersectsBox","shouldClip","updateTreeNodeVisibility","halfHeight","updateChildVisibility","numNodesToLoad","updateBoundingBoxVisibility","cameraPosition","center","distanceTo","radius","projectionFactor","tan","top","screenPixelRadius","boxHelper","box2","clipMatrixWorld","clipBoxWorld","__webpack_exports__"],"mappings":"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","file":"potree.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"three\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"potree\", [\"three\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"potree\"] = factory(require(\"three\"));\n\telse\n\t\troot[\"potree\"] = factory(root[\"three\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","/**\n * from: http://eloquentjavascript.net/1st_edition/appendix2.html\n *\n */\n\nexport function BinaryHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\n\nBinaryHeap.prototype = {\n  push: function(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n    // Allow it to bubble up.\n    this.bubbleUp(this.content.length - 1);\n  },\n\n  pop: function() {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it sink down.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return result;\n  },\n\n  remove: function(node) {\n    var length = this.content.length;\n    // To remove a value, we must search through the array to find\n    // it.\n    for (var i = 0; i < length; i++) {\n      if (this.content[i] != node) continue;\n      // When it is found, the process seen in 'pop' is repeated\n      // to fill up the hole.\n      var end = this.content.pop();\n      // If the element we popped was the one we needed to remove,\n      // we're done.\n      if (i == length - 1) break;\n      // Otherwise, we replace the removed element with the popped\n      // one, and allow it to float up or sink down as appropriate.\n      this.content[i] = end;\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  },\n\n  size: function() {\n    return this.content.length;\n  },\n\n  bubbleUp: function(n) {\n    // Fetch the element that has to be moved.\n    var element = this.content[n],\n      score = this.scoreFunction(element);\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = Math.floor((n + 1) / 2) - 1,\n        parent = this.content[parentN];\n      // If the parent has a lesser score, things are in order and we\n      // are done.\n      if (score >= this.scoreFunction(parent)) break;\n\n      // Otherwise, swap the parent with the current element and\n      // continue.\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  },\n\n  sinkDown: function(n) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      var swap = null;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N],\n          child1Score = this.scoreFunction(child1);\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) swap = child1N;\n      }\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap == null ? elemScore : child1Score)) swap = child2N;\n      }\n\n      // No need to swap further, we are done.\n      if (swap == null) break;\n\n      // Otherwise, swap and continue.\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  },\n};\n","module.exports = \"precision highp float;\\nprecision highp int;\\n\\nattribute vec3 position;\\nattribute vec2 uv;\\n\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n    vUv = uv;\\n\\n    gl_Position =   projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\"","module.exports = \"precision highp float;\\nprecision highp int;\\n\\nuniform mat4 projectionMatrix;\\n\\nuniform float screenWidth;\\nuniform float screenHeight;\\nuniform float near;\\nuniform float far;\\n\\nuniform sampler2D map;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n\\n\\tfloat dx = 1.0 / screenWidth;\\n\\tfloat dy = 1.0 / screenHeight;\\n\\n\\tvec3 color = vec3(0.0, 0.0, 0.0);\\n\\tcolor += texture2D(map, vUv + vec2(-dx, -dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(  0, -dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(+dx, -dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(-dx,   0)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(  0,   0)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(+dx,   0)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(-dx,  dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(  0,  dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(+dx,  dy)).rgb;\\n    \\n\\tcolor = color / 9.0;\\n\\t\\n\\tgl_FragColor = vec4(color, 1.0);\\n\\t\\n\\t\\n}\"","module.exports = \"precision highp float;\\nprecision highp int;\\n\\n#define max_clip_boxes 30\\n\\nattribute vec3 position;\\nattribute vec3 color;\\nattribute vec3 normal;\\nattribute float intensity;\\nattribute float classification;\\nattribute float returnNumber;\\nattribute float numberOfReturns;\\nattribute float pointSourceID;\\nattribute vec4 indices;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat3 normalMatrix;\\n\\nuniform float pcIndex;\\n\\nuniform float screenWidth;\\nuniform float screenHeight;\\nuniform float fov;\\nuniform float spacing;\\nuniform float near;\\nuniform float far;\\n\\n#if defined use_clip_box\\n\\tuniform mat4 clipBoxes[max_clip_boxes];\\n#endif\\n\\nuniform float heightMin;\\nuniform float heightMax;\\nuniform float size; // pixel size factor\\nuniform float minSize; // minimum pixel size\\nuniform float maxSize; // maximum pixel size\\nuniform float octreeSize;\\nuniform vec3 bbSize;\\nuniform vec3 uColor;\\nuniform float opacity;\\nuniform float clipBoxCount;\\nuniform float level;\\nuniform float vnStart;\\nuniform bool isLeafNode;\\n\\nuniform float filterByNormalThreshold;\\nuniform vec2 intensityRange;\\nuniform float opacityAttenuation;\\nuniform float intensityGamma;\\nuniform float intensityContrast;\\nuniform float intensityBrightness;\\nuniform float rgbGamma;\\nuniform float rgbContrast;\\nuniform float rgbBrightness;\\nuniform float transition;\\nuniform float wRGB;\\nuniform float wIntensity;\\nuniform float wElevation;\\nuniform float wClassification;\\nuniform float wReturnNumber;\\nuniform float wSourceID;\\n\\nuniform sampler2D visibleNodes;\\nuniform sampler2D gradient;\\nuniform sampler2D classificationLUT;\\nuniform sampler2D depthMap;\\n\\n#ifndef color_type_point_index\\n\\tvarying float vOpacity;\\n#endif\\nvarying vec3\\tvColor;\\nvarying float\\tvLinearDepth;\\n\\nvarying vec3\\tvViewPosition;\\nvarying float   vRadius;\\nvarying vec3\\tvNormal;\\n\\n#if defined use_edl\\n\\tvarying float vLogDepth;\\n#endif\\n\\n// ---------------------\\n// OCTREE\\n// ---------------------\\n\\n#if (defined(adaptive_point_size) || defined(color_type_lod)) && defined(tree_type_octree)\\n\\n/**\\n * Rounds the specified number to the closest integer.\\n */\\nfloat round(float number){\\n\\treturn floor(number + 0.5);\\n}\\n\\n/**\\n * Gets the number of 1-bits up to inclusive index position.\\n * \\n * number is treated as if it were an integer in the range 0-255\\n */\\nint numberOfOnes(int number, int index) {\\n\\tint numOnes = 0;\\n\\tint tmp = 128;\\n\\tfor (int i = 7; i >= 0; i--) {\\n\\n\\t\\tif (number >= tmp) {\\n\\t\\t\\tnumber = number - tmp;\\n\\n\\t\\t\\tif (i <= index) {\\n\\t\\t\\t\\tnumOnes++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\ttmp = tmp / 2;\\n\\t}\\n\\n\\treturn numOnes;\\n}\\n\\n/**\\n * Checks whether the bit at index is 1.0\\n *\\n * number is treated as if it were an integer in the range 0-255\\n */\\nbool isBitSet(int number, int index){\\n\\n\\t// weird multi else if due to lack of proper array, int and bitwise support in WebGL 1.0\\n\\tint powi = 1;\\n\\tif (index == 0) {\\n\\t\\tpowi = 1;\\n\\t} else if (index == 1) {\\n\\t\\tpowi = 2;\\n\\t} else if (index == 2) {\\n\\t\\tpowi = 4;\\n\\t} else if (index == 3) {\\n\\t\\tpowi = 8;\\n\\t} else if (index == 4) {\\n\\t\\tpowi = 16;\\n\\t} else if (index == 5) {\\n\\t\\tpowi = 32;\\n\\t} else if (index == 6) {\\n\\t\\tpowi = 64;\\n\\t} else if (index == 7) {\\n\\t\\tpowi = 128;\\n\\t}\\n\\n\\tint ndp = number / powi;\\n\\n\\treturn mod(float(ndp), 2.0) != 0.0;\\n}\\n\\n/**\\n * Gets the the LOD at the point position.\\n */\\nfloat getLOD() {\\n\\tvec3 offset = vec3(0.0, 0.0, 0.0);\\n\\tint iOffset = int(vnStart);\\n\\tfloat depth = level;\\n\\n\\tfor (float i = 0.0; i <= 30.0; i++) {\\n\\t\\tfloat nodeSizeAtLevel = octreeSize  / pow(2.0, i + level + 0.0);\\n\\t\\t\\n\\t\\tvec3 index3d = (position-offset) / nodeSizeAtLevel;\\n\\t\\tindex3d = floor(index3d + 0.5);\\n\\t\\tint index = int(round(4.0 * index3d.x + 2.0 * index3d.y + index3d.z));\\n\\t\\t\\n\\t\\tvec4 value = texture2D(visibleNodes, vec2(float(iOffset) / 2048.0, 0.0));\\n\\t\\tint mask = int(round(value.r * 255.0));\\n\\n\\t\\tif (isBitSet(mask, index)) {\\n\\t\\t\\t// there are more visible child nodes at this position\\n\\t\\t\\tint advanceG = int(round(value.g * 255.0)) * 256;\\n\\t\\t\\tint advanceB = int(round(value.b * 255.0));\\n\\t\\t\\tint advanceChild = numberOfOnes(mask, index - 1);\\n\\t\\t\\tint advance = advanceG + advanceB + advanceChild;\\n\\n\\t\\t\\tiOffset = iOffset + advance;\\n\\n\\t\\t\\tdepth++;\\n\\t\\t} else {\\n\\t\\t\\treturn value.a * 255.0; // no more visible child nodes at this position\\n\\t\\t}\\n\\t\\t\\n\\t\\toffset = offset + (vec3(1.0, 1.0, 1.0) * nodeSizeAtLevel * 0.5) * index3d;  \\n\\t}\\n\\t\\t\\n\\treturn depth;\\n}\\n\\nfloat getPointSizeAttenuation() {\\n\\treturn 0.5 * pow(2.0, getLOD());\\n}\\n\\n#endif\\n\\n// ---------------------\\n// KD-TREE\\n// ---------------------\\n\\n#if (defined(adaptive_point_size) || defined(color_type_lod)) && defined(tree_type_kdtree)\\n\\nfloat getLOD() {\\n\\tvec3 offset = vec3(0.0, 0.0, 0.0);\\n\\tfloat intOffset = 0.0;\\n\\tfloat depth = 0.0;\\n\\t\\t\\t\\n\\tvec3 size = bbSize;\\t\\n\\tvec3 pos = position;\\n\\t\\t\\n\\tfor (float i = 0.0; i <= 1000.0; i++) {\\n\\t\\t\\n\\t\\tvec4 value = texture2D(visibleNodes, vec2(intOffset / 2048.0, 0.0));\\n\\t\\t\\n\\t\\tint children = int(value.r * 255.0);\\n\\t\\tfloat next = value.g * 255.0;\\n\\t\\tint split = int(value.b * 255.0);\\n\\t\\t\\n\\t\\tif (next == 0.0) {\\n\\t\\t \\treturn depth;\\n\\t\\t}\\n\\t\\t\\n\\t\\tvec3 splitv = vec3(0.0, 0.0, 0.0);\\n\\t\\tif (split == 1) {\\n\\t\\t\\tsplitv.x = 1.0;\\n\\t\\t} else if (split == 2) {\\n\\t\\t \\tsplitv.y = 1.0;\\n\\t\\t} else if (split == 4) {\\n\\t\\t \\tsplitv.z = 1.0;\\n\\t\\t}\\n\\t\\t\\n\\t\\tintOffset = intOffset + next;\\n\\t\\t\\n\\t\\tfloat factor = length(pos * splitv / size);\\n\\t\\tif (factor < 0.5) {\\n\\t\\t \\t// left\\n\\t\\t\\tif (children == 0 || children == 2) {\\n\\t\\t\\t\\treturn depth;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// right\\n\\t\\t\\tpos = pos - size * splitv * 0.5;\\n\\t\\t\\tif (children == 0 || children == 1) {\\n\\t\\t\\t\\treturn depth;\\n\\t\\t\\t}\\n\\t\\t\\tif (children == 3) {\\n\\t\\t\\t\\tintOffset = intOffset + 1.0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsize = size * ((1.0 - (splitv + 1.0) / 2.0) + 0.5);\\n\\t\\t\\n\\t\\tdepth++;\\n\\t}\\n\\t\\t\\n\\t\\t\\n\\treturn depth;\\t\\n}\\n\\nfloat getPointSizeAttenuation() {\\n\\treturn 0.5 * pow(1.3, getLOD());\\n}\\n\\n#endif\\n\\n// formula adapted from: http://www.dfstudios.co.uk/articles/programming/image-programming-algorithms/image-processing-algorithms-part-5-contrast-adjustment/\\nfloat getContrastFactor(float contrast) {\\n\\treturn (1.0158730158730156 * (contrast + 1.0)) / (1.0158730158730156 - contrast);\\n}\\n\\nvec3 getRGB() {\\n\\t#if defined(use_rgb_gamma_contrast_brightness)\\n\\t  vec3 rgb = color;\\n\\t\\trgb = pow(rgb, vec3(rgbGamma));\\n\\t\\trgb = rgb + rgbBrightness;\\n\\t\\trgb = (rgb - 0.5) * getContrastFactor(rgbContrast) + 0.5;\\n\\t\\trgb = clamp(rgb, 0.0, 1.0);\\n\\t\\treturn rgb;\\n\\t#else\\n\\t\\treturn color;\\n\\t#endif\\n}\\n\\nfloat getIntensity() {\\n\\tfloat w = (intensity - intensityRange.x) / (intensityRange.y - intensityRange.x);\\n\\tw = pow(w, intensityGamma);\\n\\tw = w + intensityBrightness;\\n\\tw = (w - 0.5) * getContrastFactor(intensityContrast) + 0.5;\\n\\tw = clamp(w, 0.0, 1.0);\\n\\t\\n\\treturn w;\\n}\\n\\nvec3 getElevation() {\\n\\tvec4 world = modelMatrix * vec4( position, 1.0 );\\n\\tfloat w = (world.z - heightMin) / (heightMax-heightMin);\\n\\tvec3 cElevation = texture2D(gradient, vec2(w,1.0-w)).rgb;\\n\\t\\n\\treturn cElevation;\\n}\\n\\nvec4 getClassification() {\\n\\tvec2 uv = vec2(classification / 255.0, 0.5);\\n\\tvec4 classColor = texture2D(classificationLUT, uv);\\n\\t\\n\\treturn classColor;\\n}\\n\\nvec3 getReturnNumber() {\\n\\tif (numberOfReturns == 1.0) {\\n\\t\\treturn vec3(1.0, 1.0, 0.0);\\n\\t} else {\\n\\t\\tif (returnNumber == 1.0) {\\n\\t\\t\\treturn vec3(1.0, 0.0, 0.0);\\n\\t\\t} else if (returnNumber == numberOfReturns) {\\n\\t\\t\\treturn vec3(0.0, 0.0, 1.0);\\n\\t\\t} else {\\n\\t\\t\\treturn vec3(0.0, 1.0, 0.0);\\n\\t\\t}\\n\\t}\\n}\\n\\nvec3 getSourceID() {\\n\\tfloat w = mod(pointSourceID, 10.0) / 10.0;\\n\\treturn texture2D(gradient, vec2(w, 1.0 - w)).rgb;\\n}\\n\\nvec3 getCompositeColor() {\\n\\tvec3 c;\\n\\tfloat w;\\n\\n\\tc += wRGB * getRGB();\\n\\tw += wRGB;\\n\\t\\n\\tc += wIntensity * getIntensity() * vec3(1.0, 1.0, 1.0);\\n\\tw += wIntensity;\\n\\t\\n\\tc += wElevation * getElevation();\\n\\tw += wElevation;\\n\\t\\n\\tc += wReturnNumber * getReturnNumber();\\n\\tw += wReturnNumber;\\n\\t\\n\\tc += wSourceID * getSourceID();\\n\\tw += wSourceID;\\n\\t\\n\\tvec4 cl = wClassification * getClassification();\\n\\tc += cl.a * cl.rgb;\\n\\tw += wClassification * cl.a;\\n\\n\\tc = c / w;\\n\\t\\n\\tif (w == 0.0) {\\n\\t\\tgl_Position = vec4(100.0, 100.0, 100.0, 0.0);\\n\\t}\\n\\t\\n\\treturn c;\\n}\\n\\nvoid main() {\\n\\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n\\tvViewPosition = mvPosition.xyz;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\tvLinearDepth = gl_Position.w;\\n\\tvNormal = normalize(normalMatrix * normal);\\n\\n\\t#if defined use_edl\\n\\t\\tvLogDepth = log2(-mvPosition.z);\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// POINT SIZE\\n\\t// ---------------------\\n\\n\\tfloat pointSize = 1.0;\\n\\tfloat slope = tan(fov / 2.0);\\n\\tfloat projFactor =  -0.5 * screenHeight / (slope * vViewPosition.z);\\n\\n\\t#if defined fixed_point_size\\n\\t\\tpointSize = size;\\n\\t#elif defined attenuated_point_size\\n\\t\\tpointSize = size * spacing * projFactor;\\n\\t#elif defined adaptive_point_size\\n\\t\\tfloat worldSpaceSize = 2.0 * size * spacing / getPointSizeAttenuation();\\n\\t\\tpointSize = worldSpaceSize * projFactor;\\n\\t#endif\\n\\n\\tpointSize = max(minSize, pointSize);\\n\\tpointSize = min(maxSize, pointSize);\\n\\n\\tvRadius = pointSize / projFactor;\\n\\t\\n\\tgl_PointSize = pointSize;\\n\\n\\t// ---------------------\\n\\t// OPACITY\\n\\t// ---------------------\\n\\n\\t#ifndef color_type_point_index\\n\\t\\t#ifdef attenuated_opacity\\n\\t\\t\\tvOpacity = opacity * exp(-length(-mvPosition.xyz) / opacityAttenuation);\\n\\t\\t#else\\n\\t\\t\\tvOpacity = opacity;\\n\\t\\t#endif\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// FILTERING\\n\\t// ---------------------\\n\\n\\t#ifdef use_filter_by_normal\\n\\t\\tif(abs((modelViewMatrix * vec4(normal, 0.0)).z) > filterByNormalThreshold) {\\n\\t\\t\\t// Move point outside clip space space to discard it.\\n\\t\\t\\tgl_Position = vec4(0.0, 0.0, 2.0, 1.0);\\n\\t\\t}\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// POINT COLOR\\n\\t// ---------------------\\t\\n\\n\\t#ifdef color_type_rgb\\n\\t\\tvColor = getRGB();\\n\\t#elif defined color_type_height\\n\\t\\tvColor = getElevation();\\n\\t#elif defined color_type_rgb_height\\n\\t\\tvec3 cHeight = getElevation();\\n\\t\\tvColor = (1.0 - transition) * getRGB() + transition * cHeight;\\n\\t#elif defined color_type_depth\\n\\t\\tfloat linearDepth = -mvPosition.z ;\\n\\t\\tfloat expDepth = (gl_Position.z / gl_Position.w) * 0.5 + 0.5;\\n\\t\\tvColor = vec3(linearDepth, expDepth, 0.0);\\n\\t#elif defined color_type_intensity\\n\\t\\tfloat w = getIntensity();\\n\\t\\tvColor = vec3(w, w, w);\\n\\t#elif defined color_type_intensity_gradient\\n\\t\\tfloat w = getIntensity();\\n\\t\\tvColor = texture2D(gradient, vec2(w, 1.0 - w)).rgb;\\n\\t#elif defined color_type_color\\n\\t\\tvColor = uColor;\\n\\t#elif defined color_type_lod\\n\\tfloat w = getLOD() / 10.0;\\n\\tvColor = texture2D(gradient, vec2(w, 1.0 - w)).rgb;\\n\\t#elif defined color_type_point_index\\n\\t\\tvColor = indices.rgb;\\n\\t#elif defined color_type_classification\\n\\t  vec4 cl = getClassification(); \\n\\t\\tvColor = cl.rgb;\\n\\t#elif defined color_type_return_number\\n\\t\\tvColor = getReturnNumber();\\n\\t#elif defined color_type_source\\n\\t\\tvColor = getSourceID();\\n\\t#elif defined color_type_normal\\n\\t\\tvColor = (modelMatrix * vec4(normal, 0.0)).xyz;\\n\\t#elif defined color_type_phong\\n\\t\\tvColor = color;\\n\\t#elif defined color_type_composite\\n\\t\\tvColor = getCompositeColor();\\n\\t#endif\\n\\t\\n\\t#if !defined color_type_composite && defined color_type_classification\\n\\t\\tif (cl.a == 0.0) {\\n\\t\\t\\tgl_Position = vec4(100.0, 100.0, 100.0, 0.0);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// CLIPPING\\n\\t// ---------------------\\n\\n\\t#if defined use_clip_box\\n\\t\\tbool insideAny = false;\\n\\t\\tfor (int i = 0; i < MAX_CLIP_BOXES; i++) {\\n\\t\\t\\tif (i == int(clipBoxCount)) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\tvec4 clipPosition = clipBoxes[i] * modelMatrix * vec4(position, 1.0);\\n\\t\\t\\tbool inside = -0.5 <= clipPosition.x && clipPosition.x <= 0.5;\\n\\t\\t\\tinside = inside && -0.5 <= clipPosition.y && clipPosition.y <= 0.5;\\n\\t\\t\\tinside = inside && -0.5 <= clipPosition.z && clipPosition.z <= 0.5;\\n\\t\\t\\tinsideAny = insideAny || inside;\\n\\t\\t}\\n\\n\\t\\tif (!insideAny) {\\n\\t\\t\\t#if defined clip_outside\\n\\t\\t\\t\\tgl_Position = vec4(1000.0, 1000.0, 1000.0, 1.0);\\n\\t\\t\\t#elif defined clip_highlight_inside && !defined(color_type_depth)\\n\\t\\t\\t\\tfloat c = (vColor.r + vColor.g + vColor.b) / 6.0;\\n\\t\\t\\t#endif\\n\\t\\t} else {\\n\\t\\t\\t#if defined clip_highlight_inside\\n\\t\\t\\t\\tvColor.r += 0.5;\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t#endif\\n}\"","module.exports = \"precision highp float;\\nprecision highp int;\\n\\n#if defined paraboloid_point_shape\\n\\t#extension GL_EXT_frag_depth : enable\\n#endif\\n\\nuniform mat4 viewMatrix;\\nuniform vec3 cameraPosition;\\n\\nuniform mat4 projectionMatrix;\\nuniform float opacity;\\n\\nuniform float blendHardness;\\nuniform float blendDepthSupplement;\\nuniform float fov;\\nuniform float spacing;\\nuniform float near;\\nuniform float far;\\nuniform float pcIndex;\\nuniform float screenWidth;\\nuniform float screenHeight;\\n\\nuniform sampler2D depthMap;\\n\\nvarying vec3\\tvColor;\\n#ifndef color_type_point_index\\n\\tvarying float vOpacity;\\n#endif\\nvarying float\\tvLinearDepth;\\nvarying float\\tvLogDepth;\\nvarying vec3\\tvViewPosition;\\nvarying float\\tvRadius;\\nvarying vec3\\tvNormal;\\n\\nfloat specularStrength = 1.0;\\n\\nvoid main() {\\n\\tvec3 color = vColor;\\n\\tfloat depth = gl_FragCoord.z;\\n\\n\\t#if defined(circle_point_shape) || defined(paraboloid_point_shape) || defined (weighted_splats)\\n\\t\\tfloat u = 2.0 * gl_PointCoord.x - 1.0;\\n\\t\\tfloat v = 2.0 * gl_PointCoord.y - 1.0;\\n\\t#endif\\n\\t\\n\\t#if defined(circle_point_shape) || defined (weighted_splats)\\n\\t\\tfloat cc = u*u + v*v;\\n\\t\\tif(cc > 1.0){\\n\\t\\t\\tdiscard;\\n\\t\\t}\\n\\t#endif\\n\\t\\n\\t#if defined weighted_splats\\n\\t\\tvec2 uv = gl_FragCoord.xy / vec2(screenWidth, screenHeight);\\n\\t\\tfloat sDepth = texture2D(depthMap, uv).r;\\n\\t\\tif(vLinearDepth > sDepth + vRadius + blendDepthSupplement){\\n\\t\\t\\tdiscard;\\n\\t\\t}\\n\\t#endif\\n\\t\\t\\n\\t#if defined color_type_point_index\\n\\t\\tgl_FragColor = vec4(color, pcIndex / 255.0);\\n\\t#else\\n\\t\\tgl_FragColor = vec4(color, vOpacity);\\n\\t#endif\\n\\n\\tvec3 normal = normalize( vNormal );\\n\\tnormal.z = abs(normal.z);\\n\\tvec3 viewPosition = normalize( vViewPosition );\\n\\t\\n\\t#if defined(color_type_phong)\\n\\n\\t// code taken from three.js phong light fragment shader\\n\\t\\n\\t\\t#if MAX_POINT_LIGHTS > 0\\n\\n\\t\\t\\tvec3 pointDiffuse = vec3( 0.0 );\\n\\t\\t\\tvec3 pointSpecular = vec3( 0.0 );\\n\\n\\t\\t\\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n\\t\\t\\t\\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\n\\t\\t\\t\\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\n\\n\\t\\t\\t\\tfloat lDistance = 1.0;\\n\\t\\t\\t\\tif ( pointLightDistance[ i ] > 0.0 )\\n\\t\\t\\t\\t\\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\n\\n\\t\\t\\t\\tlVector = normalize( lVector );\\n\\n\\t\\t\\t\\t\\t\\t// diffuse\\n\\n\\t\\t\\t\\tfloat dotProduct = dot( normal, lVector );\\n\\n\\t\\t\\t\\t#ifdef WRAP_AROUND\\n\\n\\t\\t\\t\\t\\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\\n\\t\\t\\t\\t\\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\\t\\t\\t\\t\\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\n\\n\\t\\t\\t\\t#else\\n\\n\\t\\t\\t\\t\\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\tpointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\\n\\n\\t\\t\\t\\t// specular\\n\\n\\t\\t\\t\\tvec3 pointHalfVector = normalize( lVector + viewPosition );\\n\\t\\t\\t\\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\n\\t\\t\\t\\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\n\\n\\t\\t\\t\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\\t\\t\\t\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\\n\\t\\t\\t\\tpointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\\n\\t\\t\\t\\tpointSpecular = vec3(0.0, 0.0, 0.0);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t#endif\\n\\t\\t\\n\\t\\t#if MAX_DIR_LIGHTS > 0\\n\\n\\t\\t\\tvec3 dirDiffuse = vec3( 0.0 );\\n\\t\\t\\tvec3 dirSpecular = vec3( 0.0 );\\n\\n\\t\\t\\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\t\\t\\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\n\\t\\t\\t\\tvec3 dirVector = normalize( lDirection.xyz );\\n\\n\\t\\t\\t\\t\\t\\t// diffuse\\n\\n\\t\\t\\t\\tfloat dotProduct = dot( normal, dirVector );\\n\\n\\t\\t\\t\\t#ifdef WRAP_AROUND\\n\\n\\t\\t\\t\\t\\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\\n\\t\\t\\t\\t\\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\\t\\t\\t\\t\\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\\n\\n\\t\\t\\t\\t#else\\n\\n\\t\\t\\t\\t\\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\tdirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\\n\\n\\t\\t\\t\\t// specular\\n\\n\\t\\t\\t\\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\\n\\t\\t\\t\\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\n\\t\\t\\t\\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\n\\n\\t\\t\\t\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\\t\\t\\t\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\\n\\t\\t\\t\\tdirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\n\\t\\t\\t}\\n\\n\\t\\t#endif\\n\\t\\t\\n\\t\\tvec3 totalDiffuse = vec3( 0.0 );\\n\\t\\tvec3 totalSpecular = vec3( 0.0 );\\n\\t\\t\\n\\t\\t#if MAX_POINT_LIGHTS > 0\\n\\n\\t\\t\\ttotalDiffuse += pointDiffuse;\\n\\t\\t\\ttotalSpecular += pointSpecular;\\n\\n\\t\\t#endif\\n\\t\\t\\n\\t\\t#if MAX_DIR_LIGHTS > 0\\n\\n\\t\\t\\ttotalDiffuse += dirDiffuse;\\n\\t\\t\\ttotalSpecular += dirSpecular;\\n\\n\\t\\t#endif\\n\\t\\t\\n\\t\\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\\n\\n\\t#endif\\n\\t\\n\\t#if defined weighted_splats\\n\\t    //float w = pow(1.0 - (u*u + v*v), blendHardness);\\n\\t\\t\\n\\t\\tfloat wx = 2.0 * length(2.0 * gl_PointCoord - 1.0);\\n\\t\\tfloat w = exp(-wx * wx * 0.5);\\n\\t\\t\\n\\t\\t//float distance = length(2.0 * gl_PointCoord - 1.0);\\n\\t\\t//float w = exp( -(distance * distance) / blendHardness);\\n\\t\\t\\n\\t\\tgl_FragColor.rgb = gl_FragColor.rgb * w;\\n\\t\\tgl_FragColor.a = w;\\n\\t#endif\\n\\t\\n\\t#if defined paraboloid_point_shape\\n\\t\\tfloat wi = 0.0 - ( u*u + v*v);\\n\\t\\tvec4 pos = vec4(vViewPosition, 1.0);\\n\\t\\tpos.z += wi * vRadius;\\n\\t\\tfloat linearDepth = -pos.z;\\n\\t\\tpos = projectionMatrix * pos;\\n\\t\\tpos = pos / pos.w;\\n\\t\\tfloat expDepth = pos.z;\\n\\t\\tdepth = (pos.z + 1.0) / 2.0;\\n\\t\\tgl_FragDepthEXT = depth;\\n\\t\\t\\n\\t\\t#if defined(color_type_depth)\\n\\t\\t\\tgl_FragColor.r = linearDepth;\\n\\t\\t\\tgl_FragColor.g = expDepth;\\n\\t\\t#endif\\n\\t\\t\\n\\t\\t#if defined(use_edl)\\n\\t\\t\\tgl_FragColor.a = log2(linearDepth);\\n\\t\\t#endif\\n\\t\\t\\n\\t#else\\n\\t\\t#if defined(use_edl)\\n\\t\\t\\tgl_FragColor.a = vLogDepth;\\n\\t\\t#endif\\n\\t#endif\\t\\n}\\n\"","module.exports = function() {\n  return require(\"!!/home.net/wz18huw/projects/three-loader/node_modules/worker-loader/dist/workers/InlineWorker.js\")(\"!function(t){var e={};function r(n){if(e[n])return e[n].exports;var i=e[n]={i:n,l:!1,exports:{}};return t[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}r.m=t,r.c=e,r.d=function(t,e,n){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},r.r=function(t){\\\"undefined\\\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\\\"Module\\\"}),Object.defineProperty(t,\\\"__esModule\\\",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&\\\"object\\\"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,\\\"default\\\",{enumerable:!0,value:t}),2&e&&\\\"string\\\"!=typeof t)for(var i in t)r.d(n,i,function(e){return t[e]}.bind(null,i));return n},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,\\\"a\\\",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p=\\\"\\\",r(r.s=0)}([function(t,e,r){\\\"use strict\\\";var n=r(1);onmessage=n.handleMessage},function(t,e,r){\\\"use strict\\\";var n;r.r(e),function(t){t[t.POSITION_CARTESIAN=0]=\\\"POSITION_CARTESIAN\\\",t[t.COLOR_PACKED=1]=\\\"COLOR_PACKED\\\",t[t.COLOR_FLOATS_1=2]=\\\"COLOR_FLOATS_1\\\",t[t.COLOR_FLOATS_255=3]=\\\"COLOR_FLOATS_255\\\",t[t.NORMAL_FLOATS=4]=\\\"NORMAL_FLOATS\\\",t[t.FILLER=5]=\\\"FILLER\\\",t[t.INTENSITY=6]=\\\"INTENSITY\\\",t[t.CLASSIFICATION=7]=\\\"CLASSIFICATION\\\",t[t.NORMAL_SPHEREMAPPED=8]=\\\"NORMAL_SPHEREMAPPED\\\",t[t.NORMAL_OCT16=9]=\\\"NORMAL_OCT16\\\",t[t.NORMAL=10]=\\\"NORMAL\\\"}(n||(n={}));var i={ordinal:1,size:4},a={ordinal:2,size:1},o={ordinal:3,size:1},u={ordinal:5,size:2};function s(t,e,r){return{name:t,type:e,numElements:r,byteSize:r*e.size}}var f=s(n.COLOR_PACKED,a,4),A={POSITION_CARTESIAN:s(n.POSITION_CARTESIAN,i,3),RGBA_PACKED:f,COLOR_PACKED:f,RGB_PACKED:s(n.COLOR_PACKED,a,3),NORMAL_FLOATS:s(n.NORMAL_FLOATS,i,3),FILLER_1B:s(n.FILLER,o,1),INTENSITY:s(n.INTENSITY,u,1),CLASSIFICATION:s(n.CLASSIFICATION,o,1),NORMAL_SPHEREMAPPED:s(n.NORMAL_SPHEREMAPPED,o,2),NORMAL_OCT16:s(n.NORMAL_OCT16,o,2),NORMAL:s(n.NORMAL,i,3)};!function(){function t(t){void 0===t&&(t=[]),this.attributes=[],this.byteSize=0,this.size=0;for(var e=0;e<t.length;e++){var r=t[e],n=A[r];this.attributes.push(n),this.byteSize+=n.byteSize,this.size++}}t.prototype.add=function(t){this.attributes.push(t),this.byteSize+=t.byteSize,this.size++},t.prototype.hasColors=function(){return void 0!==this.attributes.find(O)},t.prototype.hasNormals=function(){return void 0!==this.attributes.find(b)}}();function O(t){return t.name===n.COLOR_PACKED}function b(t){var e=t.name;return e===n.NORMAL_SPHEREMAPPED||e===n.NORMAL_FLOATS||e===n.NORMAL||e===n.NORMAL_OCT16}var c=function(){function t(t){this.versionMinor=0,this.version=t;var e=-1===t.indexOf(\\\".\\\")?t.length:t.indexOf(\\\".\\\");this.versionMajor=parseInt(t.substr(0,e),10),this.versionMinor=parseInt(t.substr(e+1),10),isNaN(this.versionMinor)&&(this.versionMinor=0)}return t.prototype.newerThan=function(e){var r=new t(e);return this.versionMajor>r.versionMajor||this.versionMajor===r.versionMajor&&this.versionMinor>r.versionMinor},t.prototype.equalOrHigher=function(e){var r=new t(e);return this.versionMajor>r.versionMajor||this.versionMajor===r.versionMajor&&this.versionMinor>=r.versionMinor},t.prototype.upTo=function(t){return!this.newerThan(t)},t}(),h=function(){function t(t){this.tmp=new ArrayBuffer(4),this.tmpf=new Float32Array(this.tmp),this.tmpu8=new Uint8Array(this.tmp),this.u8=new Uint8Array(t)}return t.prototype.getUint32=function(t){return this.u8[t+3]<<24|this.u8[t+2]<<16|this.u8[t+1]<<8|this.u8[t]},t.prototype.getUint16=function(t){return this.u8[t+1]<<8|this.u8[t]},t.prototype.getFloat32=function(t){var e=this.tmpu8,r=this.u8,n=this.tmpf;return e[0]=r[t+0],e[1]=r[t+1],e[2]=r[t+2],e[3]=r[t+3],n[0]},t.prototype.getUint8=function(t){return this.u8[t]},t}();r.d(e,\\\"handleMessage\\\",function(){return M});var I=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1};function M(t){for(var e=t.data.buffer,r=t.data.pointAttributes,i={attributeBuffers:{},currentOffset:0,data:new h(e),mean:[0,0,0],nodeOffset:t.data.offset,numPoints:t.data.buffer.byteLength/r.byteSize,pointAttributes:r,scale:t.data.scale,tightBoxMax:[Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY],tightBoxMin:[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY],transferables:[],version:new c(t.data.version)},a=0,o=i.pointAttributes.attributes;a<o.length;a++){var u=o[a];S(u,i),i.currentOffset+=u.byteSize}for(var s=new ArrayBuffer(4*i.numPoints),f=new Uint32Array(s),O=0;O<i.numPoints;O++)f[O]=O;i.attributeBuffers[n.CLASSIFICATION]||function(t){for(var e=new ArrayBuffer(4*t.numPoints),r=new Float32Array(e),i=0;i<t.numPoints;i++)r[i]=0;t.attributeBuffers[n.CLASSIFICATION]={buffer:e,attribute:A.CLASSIFICATION}}(i);var b={buffer:e,mean:i.mean,attributeBuffers:i.attributeBuffers,tightBoundingBox:{min:i.tightBoxMin,max:i.tightBoxMax},indices:s};postMessage(b,i.transferables)}function S(t,e){var r=function(t,e){switch(t.name){case n.POSITION_CARTESIAN:return function(t,e){for(var r=new ArrayBuffer(4*e.numPoints*3),n=new Float32Array(r),i=0;i<e.numPoints;i++){var a=void 0,o=void 0,u=void 0;e.version.newerThan(\\\"1.3\\\")?(a=e.data.getUint32(e.currentOffset+i*e.pointAttributes.byteSize+0)*e.scale,o=e.data.getUint32(e.currentOffset+i*e.pointAttributes.byteSize+4)*e.scale,u=e.data.getUint32(e.currentOffset+i*e.pointAttributes.byteSize+8)*e.scale):(a=e.data.getFloat32(i*e.pointAttributes.byteSize+0)+e.nodeOffset[0],o=e.data.getFloat32(i*e.pointAttributes.byteSize+4)+e.nodeOffset[1],u=e.data.getFloat32(i*e.pointAttributes.byteSize+8)+e.nodeOffset[2]),n[3*i+0]=a,n[3*i+1]=o,n[3*i+2]=u,e.mean[0]+=a/e.numPoints,e.mean[1]+=o/e.numPoints,e.mean[2]+=u/e.numPoints,e.tightBoxMin[0]=Math.min(e.tightBoxMin[0],a),e.tightBoxMin[1]=Math.min(e.tightBoxMin[1],o),e.tightBoxMin[2]=Math.min(e.tightBoxMin[2],u),e.tightBoxMax[0]=Math.max(e.tightBoxMax[0],a),e.tightBoxMax[1]=Math.max(e.tightBoxMax[1],o),e.tightBoxMax[2]=Math.max(e.tightBoxMax[2],u)}return{buffer:r,attribute:t}}(t,e);case n.COLOR_PACKED:return function(t,e){for(var r=new ArrayBuffer(3*e.numPoints),n=new Uint8Array(r),i=0;i<e.numPoints;i++)n[3*i+0]=e.data.getUint8(e.currentOffset+i*e.pointAttributes.byteSize+0),n[3*i+1]=e.data.getUint8(e.currentOffset+i*e.pointAttributes.byteSize+1),n[3*i+2]=e.data.getUint8(e.currentOffset+i*e.pointAttributes.byteSize+2);return{buffer:r,attribute:t}}(t,e);case n.INTENSITY:return function(t,e){for(var r=new ArrayBuffer(4*e.numPoints),n=new Float32Array(r),i=0;i<e.numPoints;i++)n[i]=e.data.getUint16(e.currentOffset+i*e.pointAttributes.byteSize);return{buffer:r,attribute:t}}(t,e);case n.CLASSIFICATION:return function(t,e){for(var r=new ArrayBuffer(e.numPoints),n=new Uint8Array(r),i=0;i<e.numPoints;i++)n[i]=e.data.getUint8(e.currentOffset+i*e.pointAttributes.byteSize);return{buffer:r,attribute:t}}(t,e);case n.NORMAL_SPHEREMAPPED:return function(t,e){for(var r=new ArrayBuffer(4*e.numPoints*3),n=new Float32Array(r),i=0;i<e.numPoints;i++){var a=e.data.getUint8(e.currentOffset+i*e.pointAttributes.byteSize+0),o=e.data.getUint8(e.currentOffset+i*e.pointAttributes.byteSize+1),u=a/255,s=o/255,f=2*u-1,A=2*s-1,O=1,b=f*-f+A*-A+1*O;O=b,f*=Math.sqrt(b),A*=Math.sqrt(b),f*=2,A*=2,O=2*O-1,n[3*i+0]=f,n[3*i+1]=A,n[3*i+2]=O}return{buffer:r,attribute:t}}(t,e);case n.NORMAL_OCT16:return function(t,e){for(var r=new ArrayBuffer(4*e.numPoints*3),n=new Float32Array(r),i=0;i<e.numPoints;i++){var a=e.data.getUint8(e.currentOffset+i*e.pointAttributes.byteSize+0),o=e.data.getUint8(e.currentOffset+i*e.pointAttributes.byteSize+1),u=a/255*2-1,s=o/255*2-1,f=1-Math.abs(u)-Math.abs(s),A=0,O=0;f>=0?(A=u,O=s):(A=-(s/I(s)-1)/I(u),O=-(u/I(u)-1)/I(s));var b=Math.sqrt(A*A+O*O+f*f);A/=b,O/=b,f/=b,n[3*i+0]=A,n[3*i+1]=O,n[3*i+2]=f}return{buffer:r,attribute:t}}(t,e);case n.NORMAL:return function(t,e){for(var r=new ArrayBuffer(4*e.numPoints*3),n=new Float32Array(r),i=0;i<e.numPoints;i++){var a=e.data.getFloat32(e.currentOffset+i*e.pointAttributes.byteSize+0),o=e.data.getFloat32(e.currentOffset+i*e.pointAttributes.byteSize+4),u=e.data.getFloat32(e.currentOffset+i*e.pointAttributes.byteSize+8);n[3*i+0]=a,n[3*i+1]=o,n[3*i+2]=u}return{buffer:r,attribute:t}}(t,e);default:return}}(t,e);void 0!==r&&(e.attributeBuffers[r.attribute.name]=r,e.transferables.push(r.buffer))}}]);\\n//# sourceMappingURL=2ecf2bf456a5c4efacca.worker.js.map\", __webpack_public_path__ + \"2ecf2bf456a5c4efacca.worker.js\");\n};","'use strict';\n\n// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string\n\nvar URL = window.URL || window.webkitURL;\n\nmodule.exports = function (content, url) {\n  try {\n    try {\n      var blob;\n\n      try {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\n        blob = new BlobBuilder();\n\n        blob.append(content);\n\n        blob = blob.getBlob();\n      } catch (e) {\n        // The proposed API\n        blob = new Blob([content]);\n      }\n\n      return new Worker(URL.createObjectURL(blob));\n    } catch (e) {\n      return new Worker('data:application/javascript,' + encodeURIComponent(content));\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error('Inline worker is not supported');\n    }\n\n    return new Worker(url);\n  }\n};","import { Box3, Matrix4, Vector3 } from 'three';\n\nexport enum ClipMode {\n  DISABLED = 0,\n  CLIP_OUTSIDE = 1,\n  HIGHLIGHT_INSIDE = 2,\n}\n\nexport interface IClipBox {\n  box: Box3;\n  inverse: Matrix4;\n  matrix: Matrix4;\n  position: Vector3;\n}\n","export enum PointSizeType {\n  FIXED = 0,\n  ATTENUATED = 1,\n  ADAPTIVE = 2,\n}\n\nexport enum PointShape {\n  SQUARE = 0,\n  CIRCLE = 1,\n  PARABOLOID = 2,\n}\n\nexport enum TreeType {\n  OCTREE = 0,\n  KDTREE = 1,\n}\n\nexport enum PointOpacityType {\n  FIXED = 0,\n  ATTENUATED = 1\n}\n\nexport enum PointColorType {\n  RGB = 0,\n  COLOR = 1,\n  DEPTH = 2,\n  HEIGHT = 3,\n  ELEVATION = 3,\n  INTENSITY = 4,\n  INTENSITY_GRADIENT = 5,\n  LOD = 6,\n  LEVEL_OF_DETAIL = 6,\n  POINT_INDEX = 7,\n  CLASSIFICATION = 8,\n  RETURN_NUMBER = 9,\n  SOURCE = 10,\n  NORMAL = 11,\n  PHONG = 12,\n  RGB_HEIGHT = 13,\n  COMPOSITE = 50,\n}\n","import { ShaderMaterial, Texture } from 'three';\nimport { IUniform } from './types';\n\n// see http://john-chapman-graphics.blogspot.co.at/2013/01/ssao-tutorial.html\n\nexport interface IBlurMaterialUniforms {\n  [name: string]: IUniform<any>;\n  near: IUniform<number>;\n  far: IUniform<number>;\n  screenWidth: IUniform<number>;\n  screenHeight: IUniform<number>;\n  map: IUniform<Texture | null>;\n}\n\nexport class BlurMaterial extends ShaderMaterial {\n  vertexShader = require('./shaders/blur.vert');\n  fragmentShader = require('./shaders/blur.frag');\n  uniforms: IBlurMaterialUniforms = {\n    near: { type: 'f', value: 0 },\n    far: { type: 'f', value: 0 },\n    screenWidth: { type: 'f', value: 0 },\n    screenHeight: { type: 'f', value: 0 },\n    map: { type: 't', value: null },\n  };\n}\n","export const DEFAULT_RGB_BRIGHTNESS = 0;\nexport const DEFAULT_RGB_CONTRAST = 0;\nexport const DEFAULT_RGB_GAMMA = 1;\nexport const DEFAULT_MAX_POINT_SIZE = 50;\nexport const DEFAULT_MIN_NODE_PIXEL_SIZE = 50;\nexport const DEFAULT_MIN_POINT_SIZE = 2;\nexport const DEFAULT_PICK_WINDOW_SIZE = 15;\nexport const DEFAULT_POINT_BUDGET = 1_000_000;\nexport const MAX_LOADS_TO_GPU = 2;\nexport const MAX_NUM_NODES_LOADING = 4;\nexport const PERSPECTIVE_CAMERA = 'PerspectiveCamera';\n","import { Vector4 } from 'three';\nimport { IClassification } from './types';\n\nexport const DEFAULT_CLASSIFICATION: IClassification = {\n  0: new Vector4(0.5, 0.5, 0.5, 1.0),\n  1: new Vector4(0.5, 0.5, 0.5, 1.0),\n  2: new Vector4(0.63, 0.32, 0.18, 1.0),\n  3: new Vector4(0.0, 1.0, 0.0, 1.0),\n  4: new Vector4(0.0, 0.8, 0.0, 1.0),\n  5: new Vector4(0.0, 0.6, 0.0, 1.0),\n  6: new Vector4(1.0, 0.66, 0.0, 1.0),\n  7: new Vector4(1.0, 0, 1.0, 1.0),\n  8: new Vector4(1.0, 0, 0.0, 1.0),\n  9: new Vector4(0.0, 0.0, 1.0, 1.0),\n  12: new Vector4(1.0, 1.0, 0.0, 1.0),\n  DEFAULT: new Vector4(0.3, 0.6, 0.6, 0.5),\n};\n","import { Color } from 'three';\nimport { IGradient } from '../types';\n\n// From chroma spectral http://gka.github.io/chroma.js/\nexport const SPECTRAL: IGradient = [\n  [0, new Color(0.3686, 0.3098, 0.6353)],\n  [0.1, new Color(0.1961, 0.5333, 0.7412)],\n  [0.2, new Color(0.4, 0.7608, 0.6471)],\n  [0.3, new Color(0.6706, 0.8667, 0.6431)],\n  [0.4, new Color(0.902, 0.9608, 0.5961)],\n  [0.5, new Color(1.0, 1.0, 0.749)],\n  [0.6, new Color(0.9961, 0.8784, 0.5451)],\n  [0.7, new Color(0.9922, 0.6824, 0.3804)],\n  [0.8, new Color(0.9569, 0.4275, 0.2627)],\n  [0.9, new Color(0.8353, 0.2431, 0.3098)],\n  [1, new Color(0.6196, 0.0039, 0.2588)],\n];\n","import {\n  CanvasTexture,\n  Color,\n  DataTexture,\n  LinearFilter,\n  NearestFilter,\n  RGBAFormat,\n  Texture,\n} from 'three';\nimport { IClassification, IGradient } from '../materials/types';\n\nexport function generateDataTexture(width: number, height: number, color: Color): Texture {\n  const size = width * height;\n  const data = new Uint8Array(4 * size);\n\n  const r = Math.floor(color.r * 255);\n  const g = Math.floor(color.g * 255);\n  const b = Math.floor(color.b * 255);\n\n  for (let i = 0; i < size; i++) {\n    data[i * 3] = r;\n    data[i * 3 + 1] = g;\n    data[i * 3 + 2] = b;\n  }\n\n  const texture = new DataTexture(data, width, height, RGBAFormat);\n  texture.needsUpdate = true;\n  texture.magFilter = NearestFilter;\n\n  return texture;\n}\n\nexport function generateGradientTexture(gradient: IGradient): Texture {\n  const size = 64;\n\n  const canvas = document.createElement('canvas');\n  canvas.width = size;\n  canvas.height = size;\n\n  const context = canvas.getContext('2d')!;\n\n  context.rect(0, 0, size, size);\n  const ctxGradient = context.createLinearGradient(0, 0, size, size);\n\n  for (let i = 0; i < gradient.length; i++) {\n    const step = gradient[i];\n    ctxGradient.addColorStop(step[0], `#${step[1].getHexString()}`);\n  }\n\n  context.fillStyle = ctxGradient;\n  context.fill();\n\n  const texture = new CanvasTexture(canvas);\n  texture.needsUpdate = true;\n\n  texture.minFilter = LinearFilter;\n  // textureImage = texture.image;\n\n  return texture;\n}\n\nexport function generateClassificationTexture(classification: IClassification): Texture {\n  const width = 256;\n  const height = 256;\n  const size = width * height;\n\n  const data = new Uint8Array(4 * size);\n\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height; y++) {\n      const i = x + width * y;\n\n      let color;\n      if (classification[x]) {\n        color = classification[x];\n      } else if (classification[x % 32]) {\n        color = classification[x % 32];\n      } else {\n        color = classification.DEFAULT;\n      }\n\n      data[4 * i + 0] = 255 * color.x;\n      data[4 * i + 1] = 255 * color.y;\n      data[4 * i + 2] = 255 * color.z;\n      data[4 * i + 3] = 255 * color.w;\n    }\n  }\n\n  const texture = new DataTexture(data, width, height, RGBAFormat);\n  texture.magFilter = NearestFilter;\n  texture.needsUpdate = true;\n\n  return texture;\n}\n","// -------------------------------------------------------------------------------------------------\n// Converted to Typescript and adapted from https://github.com/potree/potree\n// -------------------------------------------------------------------------------------------------\n\nexport enum PointAttributeName {\n  POSITION_CARTESIAN = 0, // float x, y, z;\n  COLOR_PACKED = 1, // byte r, g, b, a; \tI = [0,1]\n  COLOR_FLOATS_1 = 2, // float r, g, b; \t\tI = [0,1]\n  COLOR_FLOATS_255 = 3, // float r, g, b; \t\tI = [0,255]\n  NORMAL_FLOATS = 4, // float x, y, z;\n  FILLER = 5,\n  INTENSITY = 6,\n  CLASSIFICATION = 7,\n  NORMAL_SPHEREMAPPED = 8,\n  NORMAL_OCT16 = 9,\n  NORMAL = 10,\n}\n\nexport interface PointAttributeType {\n  ordinal: number;\n  size: number;\n}\n\nexport const POINT_ATTRIBUTE_TYPES: Record<string, PointAttributeType> = {\n  DATA_TYPE_DOUBLE: { ordinal: 0, size: 8 },\n  DATA_TYPE_FLOAT: { ordinal: 1, size: 4 },\n  DATA_TYPE_INT8: { ordinal: 2, size: 1 },\n  DATA_TYPE_UINT8: { ordinal: 3, size: 1 },\n  DATA_TYPE_INT16: { ordinal: 4, size: 2 },\n  DATA_TYPE_UINT16: { ordinal: 5, size: 2 },\n  DATA_TYPE_INT32: { ordinal: 6, size: 4 },\n  DATA_TYPE_UINT32: { ordinal: 7, size: 4 },\n  DATA_TYPE_INT64: { ordinal: 8, size: 8 },\n  DATA_TYPE_UINT64: { ordinal: 9, size: 8 },\n};\n\nexport interface IPointAttribute {\n  name: PointAttributeName;\n  type: PointAttributeType;\n  numElements: number;\n  byteSize: number;\n}\n\nexport interface IPointAttributes {\n  attributes: IPointAttribute[];\n  byteSize: number;\n  size: number;\n}\n\nfunction makePointAttribute(\n  name: PointAttributeName,\n  type: PointAttributeType,\n  numElements: number,\n): IPointAttribute {\n  return {\n    name,\n    type,\n    numElements,\n    byteSize: numElements * type.size,\n  };\n}\n\nconst RGBA_PACKED = makePointAttribute(\n  PointAttributeName.COLOR_PACKED,\n  POINT_ATTRIBUTE_TYPES.DATA_TYPE_INT8,\n  4,\n);\n\nexport const POINT_ATTRIBUTES = {\n  POSITION_CARTESIAN: makePointAttribute(\n    PointAttributeName.POSITION_CARTESIAN,\n    POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT,\n    3,\n  ),\n  RGBA_PACKED,\n  COLOR_PACKED: RGBA_PACKED,\n  RGB_PACKED: makePointAttribute(\n    PointAttributeName.COLOR_PACKED,\n    POINT_ATTRIBUTE_TYPES.DATA_TYPE_INT8,\n    3,\n  ),\n  NORMAL_FLOATS: makePointAttribute(\n    PointAttributeName.NORMAL_FLOATS,\n    POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT,\n    3,\n  ),\n  FILLER_1B: makePointAttribute(\n    PointAttributeName.FILLER,\n    POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8,\n    1,\n  ),\n  INTENSITY: makePointAttribute(\n    PointAttributeName.INTENSITY,\n    POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT16,\n    1,\n  ),\n  CLASSIFICATION: makePointAttribute(\n    PointAttributeName.CLASSIFICATION,\n    POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8,\n    1,\n  ),\n  NORMAL_SPHEREMAPPED: makePointAttribute(\n    PointAttributeName.NORMAL_SPHEREMAPPED,\n    POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8,\n    2,\n  ),\n  NORMAL_OCT16: makePointAttribute(\n    PointAttributeName.NORMAL_OCT16,\n    POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8,\n    2,\n  ),\n  NORMAL: makePointAttribute(PointAttributeName.NORMAL, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\n};\n\nexport type PointAttributeStringName = keyof typeof POINT_ATTRIBUTES;\n\nexport class PointAttributes implements IPointAttributes {\n  attributes: IPointAttribute[] = [];\n  byteSize: number = 0;\n  size: number = 0;\n\n  constructor(pointAttributeNames: PointAttributeStringName[] = []) {\n    for (let i = 0; i < pointAttributeNames.length; i++) {\n      const pointAttributeName = pointAttributeNames[i];\n      const pointAttribute = POINT_ATTRIBUTES[pointAttributeName];\n      this.attributes.push(pointAttribute);\n      this.byteSize += pointAttribute.byteSize;\n      this.size++;\n    }\n  }\n\n  add(pointAttribute: IPointAttribute): void {\n    this.attributes.push(pointAttribute);\n    this.byteSize += pointAttribute.byteSize;\n    this.size++;\n  }\n\n  hasColors(): boolean {\n    return this.attributes.find(isColorAttribute) !== undefined;\n  }\n\n  hasNormals(): boolean {\n    return this.attributes.find(isNormalAttribute) !== undefined;\n  }\n}\n\nfunction isColorAttribute({ name }: IPointAttribute): boolean {\n  return name === PointAttributeName.COLOR_PACKED;\n}\n\nfunction isNormalAttribute({ name }: IPointAttribute): boolean {\n  return (\n    name === PointAttributeName.NORMAL_SPHEREMAPPED ||\n    name === PointAttributeName.NORMAL_FLOATS ||\n    name === PointAttributeName.NORMAL ||\n    name === PointAttributeName.NORMAL_OCT16\n  );\n}\n","import {\n  AdditiveBlending,\n  Color,\n  LessEqualDepth,\n  NearestFilter,\n  NoBlending,\n  RawShaderMaterial,\n  Texture,\n  VertexColors,\n} from 'three';\nimport {\n  DEFAULT_MAX_POINT_SIZE,\n  DEFAULT_MIN_POINT_SIZE,\n  DEFAULT_RGB_BRIGHTNESS,\n  DEFAULT_RGB_CONTRAST,\n  DEFAULT_RGB_GAMMA,\n} from '../constants';\nimport { DEFAULT_CLASSIFICATION } from './classification';\nimport { ClipMode, IClipBox } from './clipping';\nimport { PointColorType, PointOpacityType, PointShape, PointSizeType, TreeType } from './enums';\nimport { SPECTRAL } from './gradients/spectral';\nimport {\n  generateClassificationTexture,\n  generateDataTexture,\n  generateGradientTexture,\n} from './texture-generation';\nimport { IClassification, IGradient, IUniform } from './types';\n\nexport interface IPointCloudMaterialParameters {\n  size: number;\n  minSize: number;\n  maxSize: number;\n  treeType: TreeType;\n}\n\nexport interface IPointCloudMaterialUniforms {\n  bbSize: IUniform<[number, number, number]>;\n  blendDepthSupplement: IUniform<number>;\n  blendHardness: IUniform<number>;\n  classificationLUT: IUniform<Texture>;\n  clipBoxCount: IUniform<number>;\n  clipBoxes: IUniform<Float32Array>;\n  depthMap: IUniform<Texture | null>;\n  diffuse: IUniform<[number, number, number]>;\n  far: IUniform<number>;\n  fov: IUniform<number>;\n  gradient: IUniform<Texture>;\n  heightMax: IUniform<number>;\n  heightMin: IUniform<number>;\n  intensityBrightness: IUniform<number>;\n  intensityContrast: IUniform<number>;\n  intensityGamma: IUniform<number>;\n  intensityRange: IUniform<[number, number]>;\n  level: IUniform<number>;\n  maxSize: IUniform<number>;\n  minSize: IUniform<number>;\n  near: IUniform<number>;\n  octreeSize: IUniform<number>;\n  opacity: IUniform<number>;\n  pcIndex: IUniform<number>;\n  rgbBrightness: IUniform<number>;\n  rgbContrast: IUniform<number>;\n  rgbGamma: IUniform<number>;\n  screenHeight: IUniform<number>;\n  screenWidth: IUniform<number>;\n  size: IUniform<number>;\n  spacing: IUniform<number>;\n  toModel: IUniform<number[]>;\n  transition: IUniform<number>;\n  uColor: IUniform<Color>;\n  visibleNodes: IUniform<Texture>;\n  vnStart: IUniform<number>;\n  wClassification: IUniform<number>;\n  wElevation: IUniform<number>;\n  wIntensity: IUniform<number>;\n  wReturnNumber: IUniform<number>;\n  wRGB: IUniform<number>;\n  wSourceID: IUniform<number>;\n  opacityAttenuation: IUniform<number>;\n  filterByNormalThreshold: IUniform<number>;\n}\n\nconst TREE_TYPE_DEFS = {\n  [TreeType.OCTREE]: 'tree_type_octree',\n  [TreeType.KDTREE]: 'tree_type_kdtree',\n};\n\nconst SIZE_TYPE_DEFS = {\n  [PointSizeType.FIXED]: 'fixed_point_size',\n  [PointSizeType.ATTENUATED]: 'attenuated_point_size',\n  [PointSizeType.ADAPTIVE]: 'adaptive_point_size',\n};\n\nconst OPACITY_DEFS = {\n  [PointOpacityType.ATTENUATED] : 'attenuated_opacity',\n  [PointOpacityType.FIXED] : 'fixed_opacity'\n};\n\nconst SHAPE_DEFS = {\n  [PointShape.SQUARE]: 'square_point_shape',\n  [PointShape.CIRCLE]: 'circle_point_shape',\n  [PointShape.PARABOLOID]: 'paraboloid_point_shape',\n};\n\nconst COLOR_DEFS = {\n  [PointColorType.RGB]: 'color_type_rgb',\n  [PointColorType.COLOR]: 'color_type_color',\n  [PointColorType.DEPTH]: 'color_type_depth',\n  [PointColorType.HEIGHT]: 'color_type_height',\n  [PointColorType.INTENSITY]: 'color_type_intensity',\n  [PointColorType.INTENSITY_GRADIENT]: 'color_type_intensity_gradient',\n  [PointColorType.LOD]: 'color_type_lod',\n  [PointColorType.POINT_INDEX]: 'color_type_point_index',\n  [PointColorType.CLASSIFICATION]: 'color_type_classification',\n  [PointColorType.RETURN_NUMBER]: 'color_type_return_number',\n  [PointColorType.SOURCE]: 'color_type_source',\n  [PointColorType.NORMAL]: 'color_type_normal',\n  [PointColorType.PHONG]: 'color_type_phong',\n  [PointColorType.RGB_HEIGHT]: 'color_type_rgb_height',\n  [PointColorType.COMPOSITE]: 'color_type_composite',\n};\n\nconst CLIP_MODE_DEFS = {\n  [ClipMode.DISABLED]: 'clip_disabled',\n  [ClipMode.CLIP_OUTSIDE]: 'clip_outside',\n  [ClipMode.HIGHLIGHT_INSIDE]: 'clip_highlight_inside',\n};\n\nexport class PointCloudMaterial extends RawShaderMaterial {\n  lights = false;\n  fog = false;\n  numClipBoxes: number = 0;\n  clipBoxes: IClipBox[] = [];\n  readonly visibleNodesTexture: Texture;\n\n  private _gradient = SPECTRAL;\n  private gradientTexture = generateGradientTexture(this._gradient);\n\n  private _classification: IClassification = DEFAULT_CLASSIFICATION;\n  private classificationTexture: Texture = generateClassificationTexture(this._classification);\n\n  uniforms: IPointCloudMaterialUniforms & Record<string, IUniform<any>> = {\n    bbSize: makeUniform('fv', [0, 0, 0] as [number, number, number]),\n    blendDepthSupplement: makeUniform('f', 0.0),\n    blendHardness: makeUniform('f', 2.0),\n    classificationLUT: makeUniform('t', this.classificationTexture),\n    clipBoxCount: makeUniform('f', 0),\n    clipBoxes: makeUniform('Matrix4fv', [] as any),\n    depthMap: makeUniform('t', null),\n    diffuse: makeUniform('fv', [1, 1, 1] as [number, number, number]),\n    far: makeUniform('f', 1.0),\n    fov: makeUniform('f', 1.0),\n    gradient: makeUniform('t', this.gradientTexture),\n    heightMax: makeUniform('f', 1.0),\n    heightMin: makeUniform('f', 0.0),\n    intensityBrightness: makeUniform('f', 0),\n    intensityContrast: makeUniform('f', 0),\n    intensityGamma: makeUniform('f', 1),\n    intensityRange: makeUniform('fv', [0, 65000] as [number, number]),\n    isLeafNode: makeUniform('b', 0),\n    level: makeUniform('f', 0.0),\n    maxSize: makeUniform('f', DEFAULT_MAX_POINT_SIZE),\n    minSize: makeUniform('f', DEFAULT_MIN_POINT_SIZE),\n    near: makeUniform('f', 0.1),\n    octreeSize: makeUniform('f', 0),\n    opacity: makeUniform('f', 1.0),\n    pcIndex: makeUniform('f', 0),\n    rgbBrightness: makeUniform('f', DEFAULT_RGB_BRIGHTNESS),\n    rgbContrast: makeUniform('f', DEFAULT_RGB_CONTRAST),\n    rgbGamma: makeUniform('f', DEFAULT_RGB_GAMMA),\n    screenHeight: makeUniform('f', 1.0),\n    screenWidth: makeUniform('f', 1.0),\n    size: makeUniform('f', 1),\n    spacing: makeUniform('f', 1.0),\n    toModel: makeUniform('Matrix4f', []),\n    transition: makeUniform('f', 0.5),\n    uColor: makeUniform('c', new Color(0xffffff)),\n    visibleNodes: makeUniform('t', this.visibleNodesTexture),\n    vnStart: makeUniform('f', 0.0),\n    wClassification: makeUniform('f', 0),\n    wElevation: makeUniform('f', 0),\n    wIntensity: makeUniform('f', 0),\n    wReturnNumber: makeUniform('f', 0),\n    wRGB: makeUniform('f', 1),\n    wSourceID: makeUniform('f', 0),\n    opacityAttenuation: makeUniform('f', 1),\n    filterByNormalThreshold: makeUniform('f', 0)\n  };\n\n  @uniform('bbSize') bbSize!: [number, number, number]; // prettier-ignore\n  @uniform('depthMap') depthMap!: Texture | null; // prettier-ignore\n  @uniform('far') far!: number; // prettier-ignore\n  @uniform('fov') fov!: number; // prettier-ignore\n  @uniform('heightMax') heightMax!: number; // prettier-ignore\n  @uniform('heightMin') heightMin!: number; // prettier-ignore\n  @uniform('intensityBrightness') intensityBrightness!: number; // prettier-ignore\n  @uniform('intensityContrast') intensityContrast!: number; // prettier-ignore\n  @uniform('intensityGamma') intensityGamma!: number; // prettier-ignore\n  @uniform('intensityRange') intensityRange!: [number, number]; // prettier-ignore\n  @uniform('maxSize') maxSize!: number; // prettier-ignore\n  @uniform('minSize') minSize!: number; // prettier-ignore\n  @uniform('near') near!: number; // prettier-ignore\n  @uniform('opacity', true) opacity!: number; // prettier-ignore\n  @uniform('rgbBrightness', true) rgbBrightness!: number; // prettier-ignore\n  @uniform('rgbContrast', true) rgbContrast!: number; // prettier-ignore\n  @uniform('rgbGamma', true) rgbGamma!: number; // prettier-ignore\n  @uniform('screenHeight') screenHeight!: number; // prettier-ignore\n  @uniform('screenWidth') screenWidth!: number; // prettier-ignore\n  @uniform('size') size!: number; // prettier-ignore\n  @uniform('spacing') spacing!: number; // prettier-ignore\n  @uniform('transition') transition!: number; // prettier-ignore\n  @uniform('uColor') color!: Color; // prettier-ignore\n  @uniform('wClassification') weightClassification!: number; // prettier-ignore\n  @uniform('wElevation') weightElevation!: number; // prettier-ignore\n  @uniform('wIntensity') weightIntensity!: number; // prettier-ignore\n  @uniform('wReturnNumber') weightReturnNumber!: number; // prettier-ignore\n  @uniform('wRGB') weightRGB!: number; // prettier-ignore\n  @uniform('wSourceID') weightSourceID!: number; // prettier-ignore\n  @uniform('opacityAttenuation') opacityAttenuation!: number; // prettier-ignore\n  @uniform('filterByNormalThreshold') filterByNormalThreshold!: number; // prettier-ignore\n\n  @requiresShaderUpdate() useClipBox: boolean = false; // prettier-ignore\n  @requiresShaderUpdate() weighted: boolean = false; // prettier-ignore\n  @requiresShaderUpdate() pointColorType: PointColorType = PointColorType.RGB; // prettier-ignore\n  @requiresShaderUpdate() pointSizeType: PointSizeType = PointSizeType.ADAPTIVE; // prettier-ignore\n  @requiresShaderUpdate() clipMode: ClipMode = ClipMode.DISABLED; // prettier-ignore\n  @requiresShaderUpdate() useEDL: boolean = false; // prettier-ignore\n  @requiresShaderUpdate() shape: PointShape = PointShape.SQUARE; // prettier-ignore\n  @requiresShaderUpdate() treeType: TreeType = TreeType.OCTREE; // prettier-ignore\n  @requiresShaderUpdate() pointOpacityType: PointOpacityType = PointOpacityType.FIXED; // prettier-ignore\n  @requiresShaderUpdate() useFilterByNormal: boolean = false; // prettier-ignore\n\n  attributes = {\n    position: { type: 'fv', value: [] },\n    color: { type: 'fv', value: [] },\n    normal: { type: 'fv', value: [] },\n    intensity: { type: 'f', value: [] },\n    classification: { type: 'f', value: [] },\n    returnNumber: { type: 'f', value: [] },\n    numberOfReturns: { type: 'f', value: [] },\n    pointSourceID: { type: 'f', value: [] },\n    indices: { type: 'fv', value: [] },\n  };\n\n  constructor(parameters: Partial<IPointCloudMaterialParameters> = {}) {\n    super();\n\n    const tex = (this.visibleNodesTexture = generateDataTexture(2048, 1, new Color(0xffffff)));\n    tex.minFilter = NearestFilter;\n    tex.magFilter = NearestFilter;\n    this.setUniform('visibleNodes', tex);\n\n    this.treeType = getValid(parameters.treeType, TreeType.OCTREE);\n    this.size = getValid(parameters.size, 1.0);\n    this.minSize = getValid(parameters.minSize, 2.0);\n    this.maxSize = getValid(parameters.maxSize, 50.0);\n\n    this.classification = DEFAULT_CLASSIFICATION;\n\n    this.defaultAttributeValues.normal = [0, 0, 0];\n    this.defaultAttributeValues.classification = [0, 0, 0];\n    this.defaultAttributeValues.indices = [0, 0, 0, 0];\n\n    this.vertexColors = VertexColors;\n\n    this.updateShaderSource();\n  }\n\n  updateShaderSource() {\n    this.vertexShader = this.applyDefines(require('./shaders/pointcloud.vert'));\n    this.fragmentShader = this.applyDefines(require('./shaders/pointcloud.frag'));\n\n    if (this.opacity === 1.0) {\n      this.blending = NoBlending;\n      this.transparent = false;\n      this.depthTest = true;\n      this.depthWrite = true;\n      this.depthFunc = LessEqualDepth;\n    } else if (this.opacity < 1.0 && !this.useEDL) {\n      this.blending = AdditiveBlending;\n      this.transparent = true;\n      this.depthTest = false;\n      this.depthWrite = true;\n    }\n\n    if (this.weighted) {\n      this.blending = AdditiveBlending;\n      this.transparent = true;\n      this.depthTest = true;\n      this.depthWrite = false;\n      this.depthFunc = LessEqualDepth;\n    }\n\n    this.needsUpdate = true;\n  }\n\n  applyDefines(shaderSrc: string): string {\n    const parts: string[] = [];\n\n    function define(value: string) {\n      parts.push(`#define ${value}`);\n    }\n\n    define(TREE_TYPE_DEFS[this.treeType]);\n    define(SIZE_TYPE_DEFS[this.pointSizeType]);\n    define(SHAPE_DEFS[this.shape]);\n    define(COLOR_DEFS[this.pointColorType]);\n    define(CLIP_MODE_DEFS[this.clipMode]);\n    define(OPACITY_DEFS[this.pointOpacityType]);\n\n    // We only perform gamma and brightness/contrast calculations per point if values are specified.\n    if (\n      this.rgbGamma !== DEFAULT_RGB_GAMMA ||\n      this.rgbBrightness !== DEFAULT_RGB_BRIGHTNESS ||\n      this.rgbContrast !== DEFAULT_RGB_CONTRAST\n    ) {\n      define('use_rgb_gamma_contrast_brightness');\n    }\n\n    if (this.useFilterByNormal) {\n      define('use_filter_by_normal');\n    }\n\n    if (this.useEDL) {\n      define('use_edl');\n    }\n\n    if (this.weighted) {\n      define('weighted_splats');\n    }\n\n    if (this.numClipBoxes > 0) {\n      define('use_clip_box');\n    }\n\n    parts.push(shaderSrc);\n\n    return parts.join('\\n');\n  }\n\n  setClipBoxes(clipBoxes: IClipBox[]): void {\n    if (!clipBoxes) {\n      return;\n    }\n\n    this.clipBoxes = clipBoxes;\n\n    const doUpdate =\n      this.numClipBoxes !== clipBoxes.length && (clipBoxes.length === 0 || this.numClipBoxes === 0);\n\n    this.numClipBoxes = clipBoxes.length;\n    this.setUniform('clipBoxCount', this.numClipBoxes);\n\n    if (doUpdate) {\n      this.updateShaderSource();\n    }\n\n    const clipBoxesLength = this.numClipBoxes * 16;\n    const clipBoxesArray = new Float32Array(clipBoxesLength);\n\n    for (let i = 0; i < this.numClipBoxes; i++) {\n      clipBoxesArray.set(clipBoxes[i].inverse.elements, 16 * i);\n    }\n\n    for (let i = 0; i < clipBoxesLength; i++) {\n      if (isNaN(clipBoxesArray[i])) {\n        clipBoxesArray[i] = Infinity;\n      }\n    }\n\n    this.setUniform('clipBoxes', clipBoxesArray);\n  }\n\n  get gradient(): IGradient {\n    return this._gradient;\n  }\n\n  set gradient(value: IGradient) {\n    if (this._gradient !== value) {\n      this._gradient = value;\n      this.gradientTexture = generateGradientTexture(this._gradient);\n      this.setUniform('gradient', this.gradientTexture);\n    }\n  }\n\n  get classification(): IClassification {\n    return this._classification;\n  }\n\n  set classification(value: IClassification) {\n    const copy: IClassification = {} as any;\n    for (const key of Object.keys(value)) {\n      copy[key] = value[key].clone();\n    }\n\n    let isEqual = false;\n    if (this._classification === undefined) {\n      isEqual = false;\n    } else {\n      isEqual = Object.keys(copy).length === Object.keys(this._classification).length;\n\n      for (const key of Object.keys(copy)) {\n        isEqual = isEqual && this._classification[key] !== undefined;\n        isEqual = isEqual && copy[key].equals(this._classification[key]);\n      }\n    }\n\n    if (!isEqual) {\n      this._classification = copy;\n      this.recomputeClassification();\n    }\n  }\n\n  private recomputeClassification(): void {\n    this.classificationTexture = generateClassificationTexture(this._classification);\n    this.setUniform('classificationLUT', this.classificationTexture);\n  }\n\n  get elevationRange(): [number, number] {\n    return [this.heightMin, this.heightMax];\n  }\n\n  set elevationRange(value: [number, number]) {\n    this.heightMin = value[0];\n    this.heightMax = value[1];\n  }\n\n  getUniform<K extends keyof IPointCloudMaterialUniforms>(\n    name: K,\n  ): IPointCloudMaterialUniforms[K]['value'] {\n    return this.uniforms === undefined ? (undefined as any) : this.uniforms[name].value;\n  }\n\n  setUniform<K extends keyof IPointCloudMaterialUniforms>(\n    name: K,\n    value: IPointCloudMaterialUniforms[K]['value'],\n  ): void {\n    if (this.uniforms === undefined) {\n      return;\n    }\n\n    const uObj = this.uniforms[name];\n\n    if (uObj.type === 'c') {\n      (uObj.value as Color).copy(value as Color);\n    } else if (value !== uObj.value) {\n      uObj.value = value;\n    }\n  }\n}\n\nfunction makeUniform<T>(type: string, value: T): IUniform<T> {\n  return { type, value };\n}\n\nfunction getValid<T>(a: T | undefined, b: T): T {\n  return a === undefined ? b : a;\n}\n\n// tslint:disable:no-invalid-this\nfunction uniform<K extends keyof IPointCloudMaterialUniforms>(\n  uniformName: K,\n  requireSrcUpdate: boolean = false,\n): PropertyDecorator {\n  return (target: Object, propertyKey: string | symbol): void => {\n    Object.defineProperty(target, propertyKey, {\n      get() {\n        return this.getUniform(uniformName);\n      },\n      set(value: any) {\n        if (value !== this.getUniform(uniformName)) {\n          this.setUniform(uniformName, value);\n          if (requireSrcUpdate) {\n            this.updateShaderSource();\n          }\n        }\n      },\n    });\n  };\n}\n\nfunction requiresShaderUpdate() {\n  return (target: Object, propertyKey: string | symbol): void => {\n    const fieldName = \"_\" + propertyKey.toString();\n\n    Object.defineProperty(target, propertyKey, {\n      get() {\n        return this[fieldName];\n      },\n      set(value: any) {\n        if (value !== this[fieldName]) {\n          this[fieldName] = value;\n          this.updateShaderSource();\n        }\n      },\n    });\n  };\n}\n","import { Box3, Matrix4, Vector3 } from 'three';\n\n/**\n * adapted from mhluska at https://github.com/mrdoob/three.js/issues/1561\n */\nexport function computeTransformedBoundingBox(box: Box3, transform: Matrix4): Box3 {\n  return new Box3().setFromPoints([\n    new Vector3(box.min.x, box.min.y, box.min.z).applyMatrix4(transform),\n    new Vector3(box.min.x, box.min.y, box.min.z).applyMatrix4(transform),\n    new Vector3(box.max.x, box.min.y, box.min.z).applyMatrix4(transform),\n    new Vector3(box.min.x, box.max.y, box.min.z).applyMatrix4(transform),\n    new Vector3(box.min.x, box.min.y, box.max.z).applyMatrix4(transform),\n    new Vector3(box.min.x, box.max.y, box.max.z).applyMatrix4(transform),\n    new Vector3(box.max.x, box.max.y, box.min.z).applyMatrix4(transform),\n    new Vector3(box.max.x, box.min.y, box.max.z).applyMatrix4(transform),\n    new Vector3(box.max.x, box.max.y, box.max.z).applyMatrix4(transform),\n  ]);\n}\n\nexport function createChildAABB(aabb: Box3, index: number): Box3 {\n  const min = aabb.min.clone();\n  const max = aabb.max.clone();\n  const size = new Vector3().subVectors(max, min);\n\n  // tslint:disable-next-line:no-bitwise\n  if ((index & 0b0001) > 0) {\n    min.z += size.z / 2;\n  } else {\n    max.z -= size.z / 2;\n  }\n\n  // tslint:disable-next-line:no-bitwise\n  if ((index & 0b0010) > 0) {\n    min.y += size.y / 2;\n  } else {\n    max.y -= size.y / 2;\n  }\n\n  // tslint:disable-next-line:no-bitwise\n  if ((index & 0b0100) > 0) {\n    min.x += size.x / 2;\n  } else {\n    max.x -= size.x / 2;\n  }\n\n  return new Box3(min, max);\n}\n","import { IPointCloudTreeNode } from '../types';\n\nexport function getIndexFromName(name: string) {\n  return parseInt(name.charAt(name.length - 1), 10);\n}\n\n/**\n * When passed to `[].sort`, sorts the array by level and index: r, r0, r3, r4, r01, r07, r30, ...\n */\nexport function byLevelAndIndex(a: IPointCloudTreeNode, b: IPointCloudTreeNode) {\n  const na = a.name;\n  const nb = b.name;\n  if (na.length !== nb.length) {\n    return na.length - nb.length;\n  } else if (na < nb) {\n    return -1;\n  } else if (na > nb) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n","/**\n * Adapted from Potree.js http://potree.org\n * Potree License: https://github.com/potree/potree/blob/1.5/LICENSE\n */\n\nimport { Box3, BufferGeometry, EventDispatcher, Sphere, Vector3 } from 'three';\nimport { PointCloudOctreeGeometry } from './point-cloud-octree-geometry';\nimport { IPointCloudTreeNode } from './types';\nimport { createChildAABB } from './utils/bounds';\nimport { getIndexFromName } from './utils/utils';\n\nexport interface NodeData {\n  children: number;\n  numPoints: number;\n  name: string;\n}\n\nconst NODE_STRIDE = 5;\n\nexport class PointCloudOctreeGeometryNode extends EventDispatcher implements IPointCloudTreeNode {\n  id: number = PointCloudOctreeGeometryNode.idCount++;\n  name: string;\n  pcoGeometry: PointCloudOctreeGeometry;\n  index: number;\n  level: number = 0;\n  spacing: number = 0;\n  hasChildren: boolean = false;\n  readonly children: ReadonlyArray<PointCloudOctreeGeometryNode | null> = [\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n  ];\n  boundingBox: Box3;\n  tightBoundingBox: Box3;\n  boundingSphere: Sphere;\n  mean: Vector3 = new Vector3();\n  numPoints: number = 0;\n  geometry: BufferGeometry = new BufferGeometry();\n  loaded: boolean = false;\n  loading: boolean = false;\n  parent: PointCloudOctreeGeometryNode | null = null;\n  oneTimeDisposeHandlers: (() => void)[] = [];\n  isLeafNode: boolean = true;\n  readonly isTreeNode: boolean = false;\n  readonly isGeometryNode: boolean = true;\n\n  private static idCount = 0;\n\n  constructor(name: string, pcoGeometry: PointCloudOctreeGeometry, boundingBox: Box3) {\n    super();\n\n    this.name = name;\n    this.index = getIndexFromName(name);\n    this.pcoGeometry = pcoGeometry;\n    this.boundingBox = boundingBox;\n    this.tightBoundingBox = boundingBox.clone();\n    this.boundingSphere = boundingBox.getBoundingSphere(new Sphere());\n  }\n\n  dispose(): void {\n    if (!this.geometry || !this.parent) {\n      return;\n    }\n\n    this.geometry.dispose();\n    this.geometry = new BufferGeometry();\n    this.loaded = false;\n\n    this.oneTimeDisposeHandlers.forEach(handler => handler());\n    this.oneTimeDisposeHandlers = [];\n  }\n\n  /**\n   * Gets the url of the binary file for this node.\n   */\n  getUrl(): string {\n    const geometry = this.pcoGeometry;\n    const version = geometry.loader.version;\n    const pathParts = [geometry.octreeDir];\n\n    if (geometry.loader && version.equalOrHigher('1.5')) {\n      pathParts.push(this.getHierarchyBaseUrl());\n      pathParts.push(this.name);\n    } else if (version.equalOrHigher('1.4')) {\n      pathParts.push(this.name);\n    } else if (version.upTo('1.3')) {\n      pathParts.push(this.name);\n    }\n\n    return pathParts.join('/');\n  }\n\n  /**\n   * Gets the url of the hierarchy file for this node.\n   */\n  getHierarchyUrl(): string {\n    return `${this.pcoGeometry.octreeDir}/${this.getHierarchyBaseUrl()}/${this.name}.hrc`;\n  }\n\n  /**\n   * Adds the specified node as a child of the current node.\n   *\n   * @param child\n   *    The node which is to be added as a child.\n   */\n  addChild(child: PointCloudOctreeGeometryNode): void {\n    (this.children as any)[child.index] = child;\n    this.isLeafNode = false;\n    child.parent = this;\n  }\n\n  /**\n   * Calls the specified callback for the current node (if includeSelf is set to true) and all its\n   * children.\n   *\n   * @param cb\n   *    The function which is to be called for each node.\n   */\n  traverse(cb: (node: PointCloudOctreeGeometryNode) => void, includeSelf = true): void {\n    const stack: PointCloudOctreeGeometryNode[] = includeSelf ? [this] : [];\n\n    let current: PointCloudOctreeGeometryNode | undefined;\n\n    while ((current = stack.pop()) !== undefined) {\n      cb(current);\n\n      for (const child of current.children) {\n        if (child !== null) {\n          stack.push(child);\n        }\n      }\n    }\n  }\n\n  load(): Promise<void> {\n    if (!this.canLoad()) {\n      return Promise.resolve();\n    }\n\n    this.loading = true;\n    this.pcoGeometry.numNodesLoading++;\n    this.pcoGeometry.needsUpdate = true;\n\n    if (\n      this.pcoGeometry.loader.version.equalOrHigher('1.5') &&\n      this.level % this.pcoGeometry.hierarchyStepSize === 0 &&\n      this.hasChildren\n    ) {\n      return this.loadHierachyThenPoints();\n    } else {\n      return this.loadPoints();\n    }\n  }\n\n  private canLoad(): boolean {\n    return (\n      !this.loading &&\n      !this.loaded &&\n      !this.pcoGeometry.disposed &&\n      !this.pcoGeometry.loader.disposed &&\n      this.pcoGeometry.numNodesLoading < this.pcoGeometry.maxNumNodesLoading\n    );\n  }\n\n  private loadPoints(): Promise<void> {\n    this.pcoGeometry.needsUpdate = true;\n    return this.pcoGeometry.loader.load(this);\n  }\n\n  private loadHierachyThenPoints(): Promise<any> {\n    if (this.level % this.pcoGeometry.hierarchyStepSize !== 0) {\n      return Promise.resolve();\n    }\n\n    return Promise.resolve(this.pcoGeometry.loader.getUrl(this.getHierarchyUrl()))\n      .then(url => this.pcoGeometry.xhrRequest(url, { mode: 'cors' }))\n      .then(res => res.arrayBuffer())\n      .then(data => this.loadHierarchy(this, data));\n  }\n\n  /**\n   * Gets the url of the folder where the hierarchy is, relative to the octreeDir.\n   */\n  private getHierarchyBaseUrl(): string {\n    const hierarchyStepSize = this.pcoGeometry.hierarchyStepSize;\n    const indices = this.name.substr(1);\n    const numParts = Math.floor(indices.length / hierarchyStepSize);\n\n    let path = 'r/';\n    for (let i = 0; i < numParts; i++) {\n      path += `${indices.substr(i * hierarchyStepSize, hierarchyStepSize)}/`;\n    }\n\n    return path.slice(0, -1);\n  }\n\n  // tslint:disable:no-bitwise\n  private loadHierarchy(node: PointCloudOctreeGeometryNode, buffer: ArrayBuffer) {\n    const view = new DataView(buffer);\n\n    const firstNodeData = this.getNodeData(node.name, 0, view);\n    node.numPoints = firstNodeData.numPoints;\n\n    // Nodes which need be visited.\n    const stack: NodeData[] = [firstNodeData];\n    // Nodes which have already been decoded. We will take nodes from the stack and place them here.\n    const decoded: NodeData[] = [];\n\n    let offset = NODE_STRIDE;\n    while (stack.length > 0) {\n      const stackNodeData = stack.shift()!;\n\n      // From the last bit, all the way to the 8th one from the right.\n      let mask = 1;\n      for (let i = 0; i < 8 && offset + 1 < buffer.byteLength; i++) {\n        if ((stackNodeData.children & mask) !== 0) {\n          const nodeData = this.getNodeData(stackNodeData.name + i, offset, view);\n\n          decoded.push(nodeData); // Node is decoded.\n          stack.push(nodeData); // Need to check its children.\n\n          offset += NODE_STRIDE; // Move over to the next node in the buffer.\n        }\n\n        mask = mask * 2;\n      }\n    }\n\n    node.pcoGeometry.needsUpdate = true;\n\n    // Map containing all the nodes.\n    const nodes = new Map<string, PointCloudOctreeGeometryNode>();\n    nodes.set(node.name, node);\n    decoded.forEach(nodeData => this.addNode(nodeData, node.pcoGeometry, nodes));\n\n    node.loadPoints();\n  }\n\n  // tslint:enable:no-bitwise\n\n  private getNodeData(name: string, offset: number, view: DataView): NodeData {\n    const children = view.getUint8(offset);\n    const numPoints = view.getUint32(offset + 1, true);\n    return { children: children, numPoints: numPoints, name };\n  }\n\n  addNode(\n    { name, numPoints, children }: NodeData,\n    pco: PointCloudOctreeGeometry,\n    nodes: Map<string, PointCloudOctreeGeometryNode>,\n  ): void {\n    const index = getIndexFromName(name);\n    const parentName = name.substring(0, name.length - 1);\n    const parentNode = nodes.get(parentName)!;\n    const level = name.length - 1;\n    const boundingBox = createChildAABB(parentNode.boundingBox, index);\n\n    const node = new PointCloudOctreeGeometryNode(name, pco, boundingBox);\n    node.level = level;\n    node.numPoints = numPoints;\n    node.hasChildren = children > 0;\n    node.spacing = pco.spacing / Math.pow(2, level);\n\n    parentNode.addChild(node);\n    nodes.set(name, node);\n  }\n}\n","import { Box3, Vector3 } from 'three';\nimport { BinaryLoader, XhrRequest } from './loading';\nimport { PointAttributes } from './point-attributes';\nimport { PointCloudOctreeGeometryNode } from './point-cloud-octree-geometry-node';\n\nexport class PointCloudOctreeGeometry {\n  disposed: boolean = false;\n  needsUpdate: boolean = true;\n  root!: PointCloudOctreeGeometryNode;\n  octreeDir: string = '';\n  hierarchyStepSize: number = -1;\n  nodes: Record<string, PointCloudOctreeGeometryNode> = {};\n  numNodesLoading: number = 0;\n  maxNumNodesLoading: number = 3;\n  spacing: number = 0;\n  pointAttributes: PointAttributes = new PointAttributes([]);\n  projection: any = null;\n  url: string | null = null;\n\n  constructor(\n    public loader: BinaryLoader,\n    public boundingBox: Box3,\n    public tightBoundingBox: Box3,\n    public offset: Vector3,\n    public xhrRequest: XhrRequest,\n  ) {}\n\n  dispose(): void {\n    this.loader.dispose();\n    this.root.traverse(node => node.dispose());\n\n    this.disposed = true;\n  }\n\n  addNodeLoadedCallback(callback: (node: PointCloudOctreeGeometryNode) => void): void {\n    this.loader.callbacks.push(callback);\n  }\n\n  clearNodeLoadedCallbacks(): void {\n    this.loader.callbacks = [];\n  }\n}\n","import { Box3, EventDispatcher, Object3D, Points, Sphere } from 'three';\nimport { PointCloudOctreeGeometryNode } from './point-cloud-octree-geometry-node';\nimport { IPointCloudTreeNode } from './types';\n\nexport class PointCloudOctreeNode extends EventDispatcher implements IPointCloudTreeNode {\n  geometryNode: PointCloudOctreeGeometryNode;\n  sceneNode: Points;\n  pcIndex: number | undefined = undefined;\n  boundingBoxNode: Object3D | null = null;\n  readonly children: (IPointCloudTreeNode | null)[];\n  readonly loaded = true;\n  readonly isTreeNode: boolean = true;\n  readonly isGeometryNode: boolean = false;\n\n  constructor(geometryNode: PointCloudOctreeGeometryNode, sceneNode: Points) {\n    super();\n\n    this.geometryNode = geometryNode;\n    this.sceneNode = sceneNode;\n    this.children = geometryNode.children.slice();\n  }\n\n  dispose(): void {\n    this.geometryNode.dispose();\n  }\n\n  traverse(cb: (node: IPointCloudTreeNode) => void, includeSelf?: boolean): void {\n    this.geometryNode.traverse(cb, includeSelf);\n  }\n\n  get id() {\n    return this.geometryNode.id;\n  }\n\n  get name() {\n    return this.geometryNode.name;\n  }\n\n  get level(): number {\n    return this.geometryNode.level;\n  }\n\n  get isLeafNode(): boolean {\n    return this.geometryNode.isLeafNode;\n  }\n\n  get numPoints(): number {\n    return this.geometryNode.numPoints;\n  }\n\n  get index() {\n    return this.geometryNode.index;\n  }\n\n  get boundingSphere(): Sphere {\n    return this.geometryNode.boundingSphere;\n  }\n\n  get boundingBox(): Box3 {\n    return this.geometryNode.boundingBox;\n  }\n\n  get spacing() {\n    return this.geometryNode.spacing;\n  }\n}\n","import { Object3D } from 'three';\nimport { IPointCloudTreeNode } from './types';\n\nexport class PointCloudTree extends Object3D {\n  root: IPointCloudTreeNode | null = null;\n\n  initialized() {\n    return this.root !== null;\n  }\n}\n","export function clamp(value: number, min: number, max: number): number {\n  return Math.min(Math.max(min, value), max);\n}\n","import {\n  Box3,\n  BufferAttribute,\n  BufferGeometry,\n  Camera,\n  Geometry,\n  LinearFilter,\n  Material,\n  Matrix4,\n  NearestFilter,\n  NoBlending,\n  Object3D,\n  PerspectiveCamera,\n  Points,\n  Ray,\n  RGBAFormat,\n  Scene,\n  Sphere,\n  Vector3,\n  Vector4,\n  WebGLRenderer,\n  WebGLRenderTarget,\n} from 'three';\nimport { DEFAULT_MIN_NODE_PIXEL_SIZE, DEFAULT_PICK_WINDOW_SIZE } from './constants';\nimport { ClipMode, PointCloudMaterial, PointColorType, PointSizeType } from './materials';\nimport { PointCloudOctreeGeometry } from './point-cloud-octree-geometry';\nimport { PointCloudOctreeGeometryNode } from './point-cloud-octree-geometry-node';\nimport { PointCloudOctreeNode } from './point-cloud-octree-node';\nimport { PointCloudTree } from './point-cloud-tree';\nimport { IPointCloudTreeNode, IPotree, PickPoint, PointCloudHit } from './types';\nimport { computeTransformedBoundingBox } from './utils/bounds';\nimport { clamp } from './utils/math';\nimport { byLevelAndIndex } from './utils/utils';\n\nexport interface PickParams {\n  pickWindowSize: number;\n  pickOutsideClipRegion: boolean;\n}\n\ninterface IPickState {\n  renderTarget: WebGLRenderTarget;\n  material: PointCloudMaterial;\n  scene: Scene;\n}\n\nconst helperVec3 = new Vector3();\n\nexport class PointCloudOctree extends PointCloudTree {\n  potree: IPotree;\n  disposed: boolean = false;\n  pcoGeometry: PointCloudOctreeGeometry;\n  boundingBox: Box3;\n  boundingSphere: Sphere;\n  material: PointCloudMaterial;\n  level: number = 0;\n  maxLevel: number = Infinity;\n  minNodePixelSize: number = DEFAULT_MIN_NODE_PIXEL_SIZE;\n  root: IPointCloudTreeNode | null = null;\n  boundingBoxNodes: Object3D[] = [];\n  visibleNodes: PointCloudOctreeNode[] = [];\n  visibleGeometry: PointCloudOctreeGeometryNode[] = [];\n  numVisiblePoints: number = 0;\n  showBoundingBox: boolean = false;\n  private visibleBounds: Box3 = new Box3();\n  private visibleNodeTextureOffsets = new Map<string, number>();\n  private pickState: IPickState | undefined;\n\n  constructor(\n    potree: IPotree,\n    pcoGeometry: PointCloudOctreeGeometry,\n    material?: PointCloudMaterial,\n  ) {\n    super();\n\n    this.name = '';\n    this.potree = potree;\n    this.root = pcoGeometry.root;\n    this.pcoGeometry = pcoGeometry;\n    this.boundingBox = pcoGeometry.boundingBox;\n    this.boundingSphere = this.boundingBox.getBoundingSphere(new Sphere());\n\n    this.position.copy(pcoGeometry.offset);\n    this.updateMatrix();\n\n    this.material = material || new PointCloudMaterial();\n    this.initMaterial(this.material);\n  }\n\n  private initMaterial(material: PointCloudMaterial): void {\n    this.updateMatrixWorld(true);\n\n    const { min, max } = computeTransformedBoundingBox(\n      this.pcoGeometry.tightBoundingBox || this.getBoundingBoxWorld(),\n      this.matrixWorld,\n    );\n\n    const bWidth = max.z - min.z;\n    material.heightMin = min.z - 0.2 * bWidth;\n    material.heightMax = max.z + 0.2 * bWidth;\n  }\n\n  dispose(): void {\n    if (this.root) {\n      this.root.dispose();\n    }\n\n    this.pcoGeometry.dispose();\n    this.material.dispose();\n\n    this.visibleNodes = [];\n    this.visibleGeometry = [];\n    this.visibleNodeTextureOffsets.clear();\n\n    if (this.pickState) {\n      this.pickState.material.dispose();\n      this.pickState.renderTarget.dispose();\n      this.pickState = undefined;\n    }\n\n    this.disposed = false;\n  }\n\n  get pointSizeType(): PointSizeType {\n    return this.material.pointSizeType;\n  }\n\n  set pointSizeType(value: PointSizeType) {\n    this.material.pointSizeType = value;\n  }\n\n  toTreeNode(\n    geometryNode: PointCloudOctreeGeometryNode,\n    parent?: PointCloudOctreeNode | null,\n  ): PointCloudOctreeNode {\n    const sceneNode = new Points(geometryNode.geometry, this.material);\n    const node = new PointCloudOctreeNode(geometryNode, sceneNode);\n    sceneNode.name = geometryNode.name;\n    sceneNode.position.copy(geometryNode.boundingBox.min);\n    sceneNode.frustumCulled = false;\n    sceneNode.onBeforeRender = this.makeOnBeforeRender(node);\n\n    if (parent) {\n      parent.sceneNode.add(sceneNode);\n      parent.children[geometryNode.index] = node;\n\n      geometryNode.oneTimeDisposeHandlers.push(() => {\n        parent.sceneNode.remove(node.sceneNode);\n        // Replace the tree node (rendered and in the GPU) with the geometry node.\n        parent.children[geometryNode.index] = geometryNode;\n      });\n    } else {\n      this.root = node;\n      this.add(sceneNode);\n    }\n\n    return node;\n  }\n\n  private makeOnBeforeRender(node: PointCloudOctreeNode) {\n    return (\n      _renderer: WebGLRenderer,\n      _scene: Scene,\n      _camera: Camera,\n      _geometry: Geometry | BufferGeometry,\n      material: Material,\n    ) => {\n      const materialUniforms = (material as PointCloudMaterial).uniforms;\n\n      materialUniforms.level.value = node.level;\n      materialUniforms.isLeafNode.value = node.isLeafNode;\n\n      const vnStart = this.visibleNodeTextureOffsets.get(node.name);\n      if (vnStart !== undefined) {\n        materialUniforms.vnStart.value = vnStart;\n      }\n\n      const pcIndex = node.pcIndex ? node.pcIndex : this.visibleNodes.indexOf(node);\n      materialUniforms.pcIndex.value = pcIndex;\n\n      // Note: when changing uniforms in onBeforeRender, the flag uniformsNeedUpdate has to be\n      // set to true to instruct ThreeJS to upload them. See also\n      // https://github.com/mrdoob/three.js/issues/9870#issuecomment-368750182.\n\n      // Remove the cast to any when uniformsNeedUpdate has been added to the typings.\n      (material as any /*ShaderMaterial*/).uniformsNeedUpdate = true;\n    };\n  }\n\n  updateVisibleBounds() {\n    const bounds = this.visibleBounds;\n    bounds.min.set(Infinity, Infinity, Infinity);\n    bounds.max.set(-Infinity, -Infinity, -Infinity);\n\n    for (const node of this.visibleNodes) {\n      if (node.isLeafNode) {\n        bounds.expandByPoint(node.boundingBox.min);\n        bounds.expandByPoint(node.boundingBox.max);\n      }\n    }\n  }\n\n  updateBoundingBoxes(): void {\n    if (!this.showBoundingBox || !this.parent) {\n      return;\n    }\n\n    let bbRoot: any = this.parent.getObjectByName('bbroot');\n    if (!bbRoot) {\n      bbRoot = new Object3D();\n      bbRoot.name = 'bbroot';\n      this.parent.add(bbRoot);\n    }\n\n    const visibleBoxes = [];\n    for (const node of this.visibleNodes) {\n      if (node.boundingBoxNode !== undefined && node.isLeafNode) {\n        visibleBoxes.push(node.boundingBoxNode);\n      }\n    }\n\n    bbRoot.children = visibleBoxes;\n  }\n\n  updateMaterial(\n    material: PointCloudMaterial,\n    visibleNodes: PointCloudOctreeNode[],\n    camera: PerspectiveCamera,\n    renderer: WebGLRenderer,\n  ): void {\n    const maxScale = Math.max(this.scale.x, this.scale.y, this.scale.z);\n    const pixelRatio = renderer.getPixelRatio();\n\n    material.fov = camera.fov * (Math.PI / 180);\n    material.screenWidth = renderer.domElement.clientWidth * pixelRatio;\n    material.screenHeight = renderer.domElement.clientHeight * pixelRatio;\n    material.near = camera.near;\n    material.far = camera.far;\n    material.spacing = this.pcoGeometry.spacing * maxScale;\n    material.uniforms.octreeSize.value = this.pcoGeometry.boundingBox.getSize(helperVec3).x;\n\n    if (\n      material.pointSizeType === PointSizeType.ADAPTIVE ||\n      material.pointColorType === PointColorType.LOD\n    ) {\n      this.updateVisibilityTextureData(visibleNodes, material);\n    }\n  }\n\n  private updateVisibilityTextureData(nodes: PointCloudOctreeNode[], material: PointCloudMaterial) {\n    nodes.sort(byLevelAndIndex);\n\n    const data = new Uint8Array(nodes.length * 4);\n    const offsetsToChild = new Array(nodes.length).fill(Infinity);\n\n    this.visibleNodeTextureOffsets.clear();\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      this.visibleNodeTextureOffsets.set(node.name, i);\n\n      if (i > 0) {\n        const parentName = node.name.slice(0, -1);\n        const parentOffset = this.visibleNodeTextureOffsets.get(parentName)!;\n        const parentOffsetToChild = i - parentOffset;\n\n        offsetsToChild[parentOffset] = Math.min(offsetsToChild[parentOffset], parentOffsetToChild);\n\n        // tslint:disable:no-bitwise\n        const offset = parentOffset * 4;\n        data[offset] = data[offset] | (1 << node.index);\n        data[offset + 1] = offsetsToChild[parentOffset] >> 8;\n        data[offset + 2] = offsetsToChild[parentOffset] % 256;\n        // tslint:enable:no-bitwise\n      }\n\n      data[i * 4 + 3] = node.name.length;\n    }\n\n    const texture = material.visibleNodesTexture;\n    texture.image.data.set(data);\n    texture.needsUpdate = true;\n  }\n\n  private helperSphere = new Sphere();\n\n  nodesOnRay(nodes: PointCloudOctreeNode[], ray: Ray): PointCloudOctreeNode[] {\n    const nodesOnRay: PointCloudOctreeNode[] = [];\n\n    const rayClone = ray.clone();\n    for (const node of nodes) {\n      const sphere = this.helperSphere.copy(node.boundingSphere).applyMatrix4(this.matrixWorld);\n\n      if (rayClone.intersectsSphere(sphere)) {\n        nodesOnRay.push(node);\n      }\n    }\n\n    return nodesOnRay;\n  }\n\n  updateMatrixWorld(force: boolean): void {\n    if (this.matrixAutoUpdate === true) {\n      this.updateMatrix();\n    }\n\n    if (this.matrixWorldNeedsUpdate === true || force === true) {\n      if (!this.parent) {\n        this.matrixWorld.copy(this.matrix);\n      } else {\n        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n      }\n\n      this.matrixWorldNeedsUpdate = false;\n\n      force = true;\n    }\n  }\n\n  hideDescendants(object: Object3D): void {\n    const toHide: Object3D[] = [];\n    addVisibleChildren(object);\n\n    while (toHide.length > 0) {\n      const objToHide = toHide.shift()!;\n      objToHide.visible = false;\n      addVisibleChildren(objToHide);\n    }\n\n    function addVisibleChildren(obj: Object3D) {\n      for (const child of obj.children) {\n        if (child.visible) {\n          toHide.push(child);\n        }\n      }\n    }\n  }\n\n  moveToOrigin(): void {\n    this.position.set(0, 0, 0); // Reset, then the matrix will be updated in getBoundingBoxWorld()\n    this.position.set(0, 0, 0).sub(this.getBoundingBoxWorld().getCenter(new Vector3()));\n  }\n\n  moveToGroundPlane(): void {\n    this.position.y += -this.getBoundingBoxWorld().min.y;\n  }\n\n  getBoundingBoxWorld(): Box3 {\n    this.updateMatrixWorld(true);\n    return computeTransformedBoundingBox(this.boundingBox, this.matrixWorld);\n  }\n\n  getVisibleExtent() {\n    return this.visibleBounds.applyMatrix4(this.matrixWorld);\n  }\n\n  pick(\n    renderer: WebGLRenderer,\n    camera: PerspectiveCamera,\n    ray: Ray,\n    params: Partial<PickParams> = {},\n  ): PickPoint | null {\n    const pixelRatio = renderer.getPixelRatio();\n    const pickWndSize = Math.floor(\n      (params.pickWindowSize || DEFAULT_PICK_WINDOW_SIZE) * pixelRatio,\n    );\n\n    const width = Math.ceil(renderer.domElement.clientWidth * pixelRatio);\n    const height = Math.ceil(renderer.domElement.clientHeight * pixelRatio);\n\n    const pickState = this.pickState ? this.pickState : (this.pickState = this.getPickState());\n    const pickMaterial = pickState.material;\n\n    // Get all the octree nodes which intersect the picking ray. We only need to render those.\n    const nodes: PointCloudOctreeNode[] = this.nodesOnRay(this.visibleNodes, ray);\n    if (nodes.length === 0) {\n      return null;\n    }\n\n    // Create copies of the nodes so we can render them differently than in the normal point cloud.\n    const tempNodes = [];\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      node.pcIndex = i + 1;\n\n      const sceneNode = node.sceneNode;\n      const tempNode = new Points(sceneNode.geometry, pickMaterial);\n      tempNode.matrix = sceneNode.matrix;\n      tempNode.matrixWorld = sceneNode.matrixWorld;\n      tempNode.matrixAutoUpdate = false;\n      tempNode.frustumCulled = false;\n      (tempNode as any).pcIndex = i + 1;\n      tempNode.onBeforeRender = this.makeOnBeforeRender(node);\n\n      tempNodes.push(tempNode);\n    }\n\n    pickState.scene.autoUpdate = false;\n    pickState.scene.children = tempNodes;\n\n    this.updatePickMaterial(pickMaterial, params);\n    this.updateMaterial(pickMaterial, nodes, camera, renderer);\n    this.updatePickRenderTarget(this.pickState, width, height);\n\n    const pixelPos = helperVec3; // Use helper vector to prevent extra allocations.\n    pixelPos.addVectors(camera.position, ray.direction).project(camera);\n    pixelPos.x = (pixelPos.x + 1) * width * 0.5;\n    pixelPos.y = (pixelPos.y + 1) * height * 0.5;\n    const halfPickWndSize = (pickWndSize - 1) / 2;\n    const x = Math.floor(clamp(pixelPos.x - halfPickWndSize, 0, width));\n    const y = Math.floor(clamp(pixelPos.y - halfPickWndSize, 0, height));\n\n    // Render the intersected nodes onto the pick render target, clipping to a small pick window.\n    renderer.setScissor(x, y, pickWndSize, pickWndSize);\n    renderer.setScissorTest(true);\n    renderer.state.buffers.depth.setTest(pickMaterial.depthTest);\n    renderer.state.buffers.depth.setMask(pickMaterial.depthWrite ? 1 : 0);\n    renderer.state.setBlending(NoBlending);\n\n    renderer.setRenderTarget(pickState.renderTarget);\n    renderer.clear(true, true, true);\n    renderer.render(pickState.scene, camera);\n\n    // Read the pixel from the pick render target.\n    const pixels = new Uint8Array(4 * pickWndSize * pickWndSize);\n    renderer.readRenderTargetPixels(pickState.renderTarget, x, y, pickWndSize, pickWndSize, pixels);\n    renderer.setScissorTest(false);\n    renderer.setRenderTarget(null!);\n\n    const ibuffer = new Uint32Array(pixels.buffer);\n\n    // Find closest hit inside pixelWindow boundaries\n    let min = Number.MAX_VALUE;\n    let hit: PointCloudHit | null = null;\n    for (let u = 0; u < pickWndSize; u++) {\n      for (let v = 0; v < pickWndSize; v++) {\n        const offset = u + v * pickWndSize;\n        const distance =\n          Math.pow(u - (pickWndSize - 1) / 2, 2) + Math.pow(v - (pickWndSize - 1) / 2, 2);\n\n        const pcIndex = pixels[4 * offset + 3];\n        pixels[4 * offset + 3] = 0;\n        const pIndex = ibuffer[offset];\n\n        if (pcIndex > 0 && distance < min) {\n          hit = {\n            pIndex: pIndex,\n            pcIndex: pcIndex - 1,\n          };\n          min = distance;\n        }\n      }\n    }\n\n    return this.getPickPoint(hit, nodes);\n  }\n\n  private getPickPoint(hit: PointCloudHit | null, nodes: PointCloudOctreeNode[]): PickPoint | null {\n    if (!hit) {\n      return null;\n    }\n\n    const point: PickPoint = {};\n\n    const points = nodes[hit.pcIndex] && nodes[hit.pcIndex].sceneNode;\n    if (!points) {\n      return null;\n    }\n\n    const attributes: BufferAttribute[] = (points.geometry as any).attributes;\n\n    for (const property in attributes) {\n      if (!attributes.hasOwnProperty(property)) {\n        continue;\n      }\n\n      const values = attributes[property];\n\n      // tslint:disable-next-line:prefer-switch\n      if (property === 'position') {\n        this.addPositionToPickPoint(point, hit, values, points);\n      } else if (property === 'normal') {\n        this.addNormalToPickPoint(point, hit, values);\n      } else if (property === 'indices') {\n        // TODO\n      } else {\n        if (values.itemSize === 1) {\n          point[property] = values.array[hit.pIndex];\n        } else {\n          const value = [];\n          for (let j = 0; j < values.itemSize; j++) {\n            value.push(values.array[values.itemSize * hit.pIndex + j]);\n          }\n          point[property] = value;\n        }\n      }\n    }\n\n    return point;\n  }\n\n  private addPositionToPickPoint(\n    point: PickPoint,\n    hit: PointCloudHit,\n    values: BufferAttribute,\n    points: Points,\n  ): void {\n    const x = values.array[3 * hit.pIndex];\n    const y = values.array[3 * hit.pIndex + 1];\n    const z = values.array[3 * hit.pIndex + 2];\n\n    point.position = new Vector3(x, y, z).applyMatrix4(points.matrixWorld);\n  }\n\n  private addNormalToPickPoint(\n    point: PickPoint,\n    hit: PointCloudHit,\n    values: BufferAttribute,\n  ): void {\n    const normalsArray = values.array;\n\n    const x = normalsArray[3 * hit.pIndex];\n    const y = normalsArray[3 * hit.pIndex + 1];\n    const z = normalsArray[3 * hit.pIndex + 2];\n\n    const normal = new Vector4(x, y, z, 0);\n    const m = new Matrix4();\n    m.getInverse(this.matrixWorld);\n    m.transpose();\n    normal.applyMatrix4(m);\n\n    point.normal = new Vector3(normal.x, normal.y, normal.z);\n    point.datasetNormal = new Vector3(x, y, z);\n  }\n\n  private getPickState() {\n    const scene = new Scene();\n\n    const material = new PointCloudMaterial();\n    material.pointColorType = PointColorType.POINT_INDEX;\n\n    return {\n      renderTarget: this.makePickRenderTarget(),\n      material: material,\n      scene: scene,\n    };\n  }\n\n  private updatePickMaterial(pickMaterial: PointCloudMaterial, params: Partial<PickParams>): void {\n    const material = this.material;\n\n    pickMaterial.pointSizeType = material.pointSizeType;\n    pickMaterial.shape = material.shape;\n    pickMaterial.size = material.size;\n    pickMaterial.minSize = material.minSize;\n    pickMaterial.maxSize = material.maxSize;\n    pickMaterial.classification = material.classification;\n\n    if (params.pickOutsideClipRegion) {\n      pickMaterial.clipMode = ClipMode.DISABLED;\n    } else {\n      pickMaterial.clipMode = material.clipMode;\n      pickMaterial.setClipBoxes(\n        material.clipMode === ClipMode.CLIP_OUTSIDE ? material.clipBoxes : [],\n      );\n    }\n  }\n\n  private updatePickRenderTarget(pickState: IPickState, width: number, height: number): void {\n    if (pickState.renderTarget.width === width || pickState.renderTarget.height === height) {\n      return;\n    }\n\n    pickState.renderTarget.dispose();\n    pickState.renderTarget = this.makePickRenderTarget();\n    pickState.renderTarget.setSize(width, height);\n  }\n\n  private makePickRenderTarget() {\n    return new WebGLRenderTarget(1, 1, {\n      minFilter: LinearFilter,\n      magFilter: NearestFilter,\n      format: RGBAFormat,\n    });\n  }\n\n  get progress() {\n    return this.visibleGeometry.length === 0\n      ? 0\n      : this.visibleNodes.length / this.visibleGeometry.length;\n  }\n}\n","const canvas = document.createElement('canvas');\nconst gl: WebGLRenderingContext | null =\n  canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n\nexport const FEATURES = {\n  SHADER_INTERPOLATION: hasExtension('EXT_frag_depth') && hasMinVaryingVectors(8),\n  SHADER_SPLATS:\n    hasExtension('EXT_frag_depth') && hasExtension('OES_texture_float') && hasMinVaryingVectors(8),\n  SHADER_EDL: hasExtension('OES_texture_float') && hasMinVaryingVectors(8),\n  precision: getPrecision(),\n};\n\nfunction hasExtension(ext: string) {\n  return gl !== null && Boolean(gl.getExtension(ext));\n}\n\nfunction hasMinVaryingVectors(value: number) {\n  return gl !== null && gl.getParameter(gl.MAX_VARYING_VECTORS) >= value;\n}\n\nfunction getPrecision() {\n  if (gl === null) {\n    return '';\n  }\n\n  const vsHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);\n  const vsMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);\n\n  const fsHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n  const fsMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);\n\n  const highpAvailable =\n    vsHighpFloat && fsHighpFloat && vsHighpFloat.precision > 0 && fsHighpFloat.precision > 0;\n\n  const mediumpAvailable =\n    vsMediumpFloat &&\n    fsMediumpFloat &&\n    vsMediumpFloat.precision > 0 &&\n    fsMediumpFloat.precision > 0;\n\n  return highpAvailable ? 'highp' : mediumpAvailable ? 'mediump' : 'lowp';\n}\n","export class Version {\n  version: string;\n  versionMajor: number;\n  versionMinor: number = 0;\n\n  constructor(version: string) {\n    this.version = version;\n\n    const vmLength = version.indexOf('.') === -1 ? version.length : version.indexOf('.');\n    this.versionMajor = parseInt(version.substr(0, vmLength), 10);\n    this.versionMinor = parseInt(version.substr(vmLength + 1), 10);\n    if (isNaN(this.versionMinor)) {\n      this.versionMinor = 0;\n    }\n  }\n\n  newerThan(version: string): boolean {\n    const v = new Version(version);\n\n    if (this.versionMajor > v.versionMajor) {\n      return true;\n    } else if (this.versionMajor === v.versionMajor && this.versionMinor > v.versionMinor) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  equalOrHigher(version: string): boolean {\n    const v = new Version(version);\n\n    if (this.versionMajor > v.versionMajor) {\n      return true;\n    } else if (this.versionMajor === v.versionMajor && this.versionMinor >= v.versionMinor) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  upTo(version: string): boolean {\n    return !this.newerThan(version);\n  }\n}\n","// -------------------------------------------------------------------------------------------------\n// Converted to Typescript and adapted from https://github.com/potree/potree\n// -------------------------------------------------------------------------------------------------\n\nimport { Box3, BufferAttribute, BufferGeometry, Uint8BufferAttribute, Vector3 } from 'three';\nimport { PointAttributeName, PointAttributeType } from '../point-attributes';\nimport { PointCloudOctreeGeometryNode } from '../point-cloud-octree-geometry-node';\nimport { Version } from '../version';\nimport { GetUrlFn, XhrRequest } from './types';\n\ninterface AttributeData {\n  attribute: {\n    name: PointAttributeName;\n    type: PointAttributeType;\n    byteSize: number;\n    numElements: number;\n  };\n  buffer: ArrayBuffer;\n}\n\ninterface WorkerResponse {\n  data: {\n    attributeBuffers: { [name: string]: AttributeData };\n    indices: ArrayBuffer;\n    tightBoundingBox: { min: number[]; max: number[] };\n    mean: number[];\n  };\n}\n\ninterface BinaryLoaderOptions {\n  getUrl?: GetUrlFn;\n  version: string;\n  boundingBox: Box3;\n  scale: number;\n  xhrRequest: XhrRequest;\n}\n\nexport class BinaryLoader {\n  version: Version;\n  boundingBox: Box3;\n  scale: number;\n  getUrl: GetUrlFn;\n  disposed: boolean = false;\n  xhrRequest: XhrRequest;\n  callbacks: ((node: PointCloudOctreeGeometryNode) => void)[];\n\n  private workers: Worker[] = [];\n\n  constructor({\n    getUrl = s => Promise.resolve(s),\n    version,\n    boundingBox,\n    scale,\n    xhrRequest,\n  }: BinaryLoaderOptions) {\n    if (typeof version === 'string') {\n      this.version = new Version(version);\n    } else {\n      this.version = version;\n    }\n\n    this.xhrRequest = xhrRequest;\n    this.getUrl = getUrl;\n    this.boundingBox = boundingBox;\n    this.scale = scale;\n    this.callbacks = [];\n  }\n\n  dispose(): void {\n    this.workers.forEach(worker => worker.terminate());\n    this.workers = [];\n\n    this.disposed = true;\n  }\n\n  load(node: PointCloudOctreeGeometryNode): Promise<void> {\n    if (node.loaded || this.disposed) {\n      return Promise.resolve();\n    }\n\n    return Promise.resolve(this.getUrl(this.getNodeUrl(node)))\n      .then(url => this.xhrRequest(url, { mode: 'cors' }))\n      .then(res => res.arrayBuffer())\n      .then(buffer => this.parse(node, buffer));\n  }\n\n  private getNodeUrl(node: PointCloudOctreeGeometryNode): string {\n    let url = node.getUrl();\n    if (this.version.equalOrHigher('1.4')) {\n      url += '.bin';\n    }\n\n    return url;\n  }\n\n  private parse(node: PointCloudOctreeGeometryNode, buffer: ArrayBuffer): void {\n    if (this.disposed) {\n      return;\n    }\n\n    const worker = this.getWorker();\n\n    const pointAttributes = node.pcoGeometry.pointAttributes;\n    const numPoints = buffer.byteLength / pointAttributes.byteSize;\n\n    if (this.version.upTo('1.5')) {\n      node.numPoints = numPoints;\n    }\n\n    worker.onmessage = (e: WorkerResponse) => {\n      if (this.disposed) {\n        return;\n      }\n\n      const data = e.data;\n\n      const geometry = (node.geometry = node.geometry || new BufferGeometry());\n      geometry.boundingBox = node.boundingBox;\n\n      this.addBufferAttributes(geometry, data.attributeBuffers);\n      this.addIndices(geometry, data.indices);\n      this.addNormalAttribute(geometry, numPoints);\n\n      node.mean = new Vector3().fromArray(data.mean);\n      node.tightBoundingBox = this.getTightBoundingBox(data.tightBoundingBox);\n      node.loaded = true;\n      node.loading = false;\n      node.pcoGeometry.numNodesLoading--;\n      node.pcoGeometry.needsUpdate = true;\n\n      this.releaseWorker(worker);\n\n      this.callbacks.forEach(callback => callback(node));\n    };\n\n    const message = {\n      buffer,\n      pointAttributes,\n      version: this.version.version,\n      min: node.boundingBox.min.toArray(),\n      offset: node.pcoGeometry.offset.toArray(),\n      scale: this.scale,\n      spacing: node.spacing,\n      hasChildren: node.hasChildren,\n    };\n\n    worker.postMessage(message, [message.buffer]);\n  }\n\n  private getWorker(): Worker {\n    const worker = this.workers.pop();\n    if (worker) {\n      return worker;\n    }\n\n    const ctor = require('worker-loader?inline!../workers/binary-decoder-worker.js');\n    return new ctor();\n  }\n\n  private releaseWorker(worker: Worker): void {\n    this.workers.push(worker);\n  }\n\n  private getTightBoundingBox({ min, max }: { min: number[]; max: number[] }): Box3 {\n    const box = new Box3(new Vector3().fromArray(min), new Vector3().fromArray(max));\n    box.max.sub(box.min);\n    box.min.set(0, 0, 0);\n\n    return box;\n  }\n\n  private addBufferAttributes(\n    geometry: BufferGeometry,\n    buffers: { [name: string]: { buffer: ArrayBuffer } },\n  ): void {\n    Object.keys(buffers).forEach(property => {\n      const buffer = buffers[property].buffer;\n\n      if (this.isAttribute(property, PointAttributeName.POSITION_CARTESIAN)) {\n        geometry.addAttribute('position', new BufferAttribute(new Float32Array(buffer), 3));\n      } else if (this.isAttribute(property, PointAttributeName.COLOR_PACKED)) {\n        geometry.addAttribute('color', new BufferAttribute(new Uint8Array(buffer), 3, true));\n      } else if (this.isAttribute(property, PointAttributeName.INTENSITY)) {\n        geometry.addAttribute('intensity', new BufferAttribute(new Float32Array(buffer), 1));\n      } else if (this.isAttribute(property, PointAttributeName.CLASSIFICATION)) {\n        geometry.addAttribute('classification', new BufferAttribute(new Uint8Array(buffer), 1));\n      } else if (this.isAttribute(property, PointAttributeName.NORMAL_SPHEREMAPPED)) {\n        geometry.addAttribute('normal', new BufferAttribute(new Float32Array(buffer), 3));\n      } else if (this.isAttribute(property, PointAttributeName.NORMAL_OCT16)) {\n        geometry.addAttribute('normal', new BufferAttribute(new Float32Array(buffer), 3));\n      } else if (this.isAttribute(property, PointAttributeName.NORMAL)) {\n        geometry.addAttribute('normal', new BufferAttribute(new Float32Array(buffer), 3));\n      }\n    });\n  }\n\n  private addIndices(geometry: BufferGeometry, indices: ArrayBuffer): void {\n    const indicesAttribute = new Uint8BufferAttribute(indices, 4);\n    indicesAttribute.normalized = true;\n    geometry.addAttribute('indices', indicesAttribute);\n  }\n\n  private addNormalAttribute(geometry: BufferGeometry, numPoints: number): void {\n    if (!geometry.getAttribute('normal')) {\n      const buffer = new Float32Array(numPoints * 3);\n      geometry.addAttribute('normal', new BufferAttribute(new Float32Array(buffer), 3));\n    }\n  }\n\n  private isAttribute(property: string, name: PointAttributeName): boolean {\n    return parseInt(property, 10) === name;\n  }\n}\n","// -------------------------------------------------------------------------------------------------\n// Converted to Typescript and adapted from https://github.com/potree/potree\n// -------------------------------------------------------------------------------------------------\n\nimport { Box3, Vector3 } from 'three';\nimport { PointAttributes, PointAttributeStringName } from '../point-attributes';\nimport { PointCloudOctreeGeometry } from '../point-cloud-octree-geometry';\nimport { PointCloudOctreeGeometryNode } from '../point-cloud-octree-geometry-node';\nimport { createChildAABB } from '../utils/bounds';\nimport { getIndexFromName } from '../utils/utils';\nimport { Version } from '../version';\nimport { BinaryLoader } from './binary-loader';\nimport { GetUrlFn, XhrRequest } from './types';\n\ninterface BoundingBoxData {\n  lx: number;\n  ly: number;\n  lz: number;\n  ux: number;\n  uy: number;\n  uz: number;\n}\n\ninterface POCJson {\n  version: string;\n  octreeDir: string;\n  projection: string;\n  points: number;\n  boundingBox: BoundingBoxData;\n  tightBoundingBox?: BoundingBoxData;\n  pointAttributes: PointAttributeStringName[];\n  spacing: number;\n  scale: number;\n  hierarchyStepSize: number;\n  hierarchy: [string, number][]; // [name, numPoints][]\n}\n\n/**\n *\n * @param url\n *    The url of the point cloud file (usually cloud.js).\n * @param getUrl\n *    Function which receives the relative URL of a point cloud chunk file which is to be loaded\n *    and shoud return a new url (e.g. signed) in the form of a string or a promise.\n * @param xhrRequest An arrow function for a fetch request\n * @returns\n *    An observable which emits once when the first LOD of the point cloud is loaded.\n */\nexport function loadPOC(\n  url: string,\n  getUrl: GetUrlFn,\n  xhrRequest: XhrRequest,\n): Promise<PointCloudOctreeGeometry> {\n  return Promise.resolve(getUrl(url)).then(transformedUrl => {\n    return xhrRequest(transformedUrl, { mode: 'cors' })\n      .then(res => res.json())\n      .then(parse(transformedUrl, getUrl, xhrRequest));\n  });\n}\n\nfunction parse(url: string, getUrl: GetUrlFn, xhrRequest: XhrRequest) {\n  return (data: POCJson): Promise<PointCloudOctreeGeometry> => {\n    const { offset, boundingBox, tightBoundingBox } = getBoundingBoxes(data);\n\n    const loader = new BinaryLoader({\n      getUrl,\n      version: data.version,\n      boundingBox,\n      scale: data.scale,\n      xhrRequest,\n    });\n\n    const pco = new PointCloudOctreeGeometry(\n      loader,\n      boundingBox,\n      tightBoundingBox,\n      offset,\n      xhrRequest,\n    );\n\n    pco.url = url;\n    pco.octreeDir = data.octreeDir;\n    pco.needsUpdate = true;\n    pco.spacing = data.spacing;\n    pco.hierarchyStepSize = data.hierarchyStepSize;\n    pco.projection = data.projection;\n    pco.offset = offset;\n    pco.pointAttributes = new PointAttributes(data.pointAttributes);\n\n    const nodes: Record<string, PointCloudOctreeGeometryNode> = {};\n\n    const version = new Version(data.version);\n\n    return loadRoot(pco, data, nodes, version).then(() => {\n      if (version.upTo('1.4')) {\n        loadRemainingHierarchy(pco, data, nodes);\n      }\n\n      pco.nodes = nodes;\n      return pco;\n    });\n  };\n}\n\nfunction getBoundingBoxes(\n  data: POCJson,\n): { offset: Vector3; boundingBox: Box3; tightBoundingBox: Box3 } {\n  const min = new Vector3(data.boundingBox.lx, data.boundingBox.ly, data.boundingBox.lz);\n  const max = new Vector3(data.boundingBox.ux, data.boundingBox.uy, data.boundingBox.uz);\n  const boundingBox = new Box3(min, max);\n  const tightBoundingBox = boundingBox.clone();\n\n  const offset = min.clone();\n\n  if (data.tightBoundingBox) {\n    const { lx, ly, lz, ux, uy, uz } = data.tightBoundingBox;\n    tightBoundingBox.min.set(lx, ly, lz);\n    tightBoundingBox.max.set(ux, uy, uz);\n  }\n\n  boundingBox.min.sub(offset);\n  boundingBox.max.sub(offset);\n  tightBoundingBox.min.sub(offset);\n  tightBoundingBox.max.sub(offset);\n\n  return { offset, boundingBox, tightBoundingBox };\n}\n\nfunction loadRoot(\n  pco: PointCloudOctreeGeometry,\n  data: POCJson,\n  nodes: Record<string, PointCloudOctreeGeometryNode>,\n  version: Version,\n): Promise<void> {\n  const name = 'r';\n\n  const root = new PointCloudOctreeGeometryNode(name, pco, pco.boundingBox);\n  root.hasChildren = true;\n  root.spacing = pco.spacing;\n\n  if (version.upTo('1.5')) {\n    root.numPoints = data.hierarchy[0][1];\n  } else {\n    root.numPoints = 0;\n  }\n\n  pco.root = root;\n  nodes[name] = root;\n  return pco.root.load();\n}\n\nfunction loadRemainingHierarchy(\n  pco: PointCloudOctreeGeometry,\n  data: POCJson,\n  nodes: Record<string, PointCloudOctreeGeometryNode>,\n): void {\n  for (let i = 1; i < data.hierarchy.length; i++) {\n    const [name, numPoints] = data.hierarchy[i];\n    const { index, parentName, level } = parseName(name);\n    const parentNode = nodes[parentName];\n\n    const boundingBox = createChildAABB(parentNode.boundingBox, index);\n    const node = new PointCloudOctreeGeometryNode(name, pco, boundingBox);\n    node.level = level;\n    node.numPoints = numPoints;\n    node.spacing = pco.spacing / Math.pow(2, node.level);\n\n    nodes[name] = node;\n    parentNode.addChild(node);\n  }\n}\n\nfunction parseName(name: string): { index: number; parentName: string; level: number } {\n  return {\n    index: getIndexFromName(name),\n    parentName: name.substring(0, name.length - 1),\n    level: name.length - 1,\n  };\n}\n","import { PointCloudOctreeGeometryNode } from './point-cloud-octree-geometry-node';\nimport { PointCloudOctreeNode } from './point-cloud-octree-node';\n\nexport function isGeometryNode(node?: any): node is PointCloudOctreeGeometryNode {\n  return node !== undefined && node !== null && node.isGeometryNode;\n}\n\nexport function isTreeNode(node?: any): node is PointCloudOctreeNode {\n  return node !== undefined && node !== null && node.isTreeNode;\n}\n","import {\n  Box3,\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  LineBasicMaterial,\n  LineSegments,\n} from 'three';\n\n/**\n *\n * code adapted from three.js BoxHelper.js\n * https://github.com/mrdoob/three.js/blob/dev/src/helpers/BoxHelper.js\n *\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / http://github.com/Mugen87\n * @author mschuetz / http://potree.org\n */\n\nexport class Box3Helper extends LineSegments {\n  constructor(box: Box3, color: Color = new Color(0xffff00)) {\n    // prettier-ignore\n    const indices = new Uint16Array([ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ]);\n    // prettier-ignore\n    const positions = new Float32Array([\n      box.min.x, box.min.y, box.min.z,\n      box.max.x, box.min.y, box.min.z,\n      box.max.x, box.min.y, box.max.z,\n      box.min.x, box.min.y, box.max.z,\n      box.min.x, box.max.y, box.min.z,\n      box.max.x, box.max.y, box.min.z,\n      box.max.x, box.max.y, box.max.z,\n      box.min.x, box.max.y, box.max.z\n    ]);\n\n    const geometry = new BufferGeometry();\n    geometry.setIndex(new BufferAttribute(indices, 1));\n    geometry.addAttribute('position', new BufferAttribute(positions, 3));\n\n    const material = new LineBasicMaterial({ color: color });\n\n    super(geometry, material);\n  }\n}\n","import { IPointCloudTreeNode } from '../types';\n\nexport type Node = IPointCloudTreeNode;\n\nexport class LRUItem {\n  next: LRUItem | null = null;\n  previous: LRUItem | null = null;\n  constructor(public node: Node) {}\n}\n\n/**\n * A doubly-linked-list of the least recently used elements.\n */\nexport class LRU {\n  // the least recently used item\n  first: LRUItem | null = null;\n  // the most recently used item\n  last: LRUItem | null = null;\n  numPoints: number = 0;\n\n  private items = new Map<number, LRUItem>();\n\n  constructor(public pointBudget: number = 1_000_000) {}\n\n  get size(): number {\n    return this.items.size;\n  }\n\n  has(node: Node): boolean {\n    return this.items.has(node.id);\n  }\n\n  /**\n   * Makes the specified the most recently used item. if the list does not contain node, it will\n   * be added.\n   */\n  touch(node: Node) {\n    if (!node.loaded) {\n      return;\n    }\n\n    const item = this.items.get(node.id);\n    if (item) {\n      this.touchExisting(item);\n    } else {\n      this.addNew(node);\n    }\n  }\n\n  private addNew(node: Node): void {\n    const item = new LRUItem(node);\n    item.previous = this.last;\n    this.last = item;\n    if (item.previous) {\n      item.previous.next = item;\n    }\n\n    if (!this.first) {\n      this.first = item;\n    }\n\n    this.items.set(node.id, item);\n    this.numPoints += node.numPoints;\n  }\n\n  private touchExisting(item: LRUItem): void {\n    if (!item.previous) {\n      // handle touch on first element\n      if (item.next) {\n        this.first = item.next;\n        this.first.previous = null;\n        item.previous = this.last;\n        item.next = null;\n        this.last = item;\n\n        if (item.previous) {\n          item.previous.next = item;\n        }\n      }\n    } else if (!item.next) {\n      // handle touch on last element\n    } else {\n      // handle touch on any other element\n      item.previous.next = item.next;\n      item.next.previous = item.previous;\n      item.previous = this.last;\n      item.next = null;\n      this.last = item;\n\n      if (item.previous) {\n        item.previous.next = item;\n      }\n    }\n  }\n\n  remove(node: Node) {\n    const item = this.items.get(node.id);\n    if (!item) {\n      return;\n    }\n\n    if (this.items.size === 1) {\n      this.first = null;\n      this.last = null;\n    } else {\n      if (!item.previous) {\n        this.first = item.next;\n        this.first!.previous = null;\n      }\n\n      if (!item.next) {\n        this.last = item.previous;\n        this.last!.next = null;\n      }\n\n      if (item.previous && item.next) {\n        item.previous.next = item.next;\n        item.next.previous = item.previous;\n      }\n    }\n\n    this.items.delete(node.id);\n    this.numPoints -= node.numPoints;\n  }\n\n  getLRUItem(): Node | undefined {\n    return this.first ? this.first.node : undefined;\n  }\n\n  freeMemory(): void {\n    if (this.items.size <= 1) {\n      return;\n    }\n\n    while (this.numPoints > this.pointBudget * 2) {\n      const node = this.getLRUItem();\n      if (node) {\n        this.disposeDescendants(node);\n      }\n    }\n  }\n\n  disposeDescendants(node: Node): void {\n    node.traverse(n => {\n      if (n.loaded) {\n        n.dispose();\n        this.remove(n);\n      }\n    });\n  }\n}\n","import {\n  Box3,\n  Camera,\n  Frustum,\n  Matrix4,\n  OrthographicCamera,\n  PerspectiveCamera,\n  Vector2,\n  Vector3,\n  WebGLRenderer,\n} from 'three';\nimport {\n  DEFAULT_POINT_BUDGET,\n  MAX_LOADS_TO_GPU,\n  MAX_NUM_NODES_LOADING,\n  PERSPECTIVE_CAMERA,\n} from './constants';\nimport { FEATURES } from './features';\nimport { GetUrlFn, loadPOC } from './loading';\nimport { ClipMode } from './materials';\nimport { PointCloudOctree } from './point-cloud-octree';\nimport { PointCloudOctreeGeometryNode } from './point-cloud-octree-geometry-node';\nimport { PointCloudOctreeNode } from './point-cloud-octree-node';\nimport { isGeometryNode, isTreeNode } from './type-predicates';\nimport { IPointCloudTreeNode, IPotree, IVisibilityUpdateResult } from './types';\nimport { BinaryHeap } from './utils/binary-heap';\nimport { Box3Helper } from './utils/box3-helper';\nimport { LRU } from './utils/lru';\n\nexport class QueueItem {\n  constructor(\n    public pointCloudIndex: number,\n    public weight: number,\n    public node: IPointCloudTreeNode,\n    public parent?: IPointCloudTreeNode | null,\n  ) {}\n}\n\nexport class Potree implements IPotree {\n  private _pointBudget: number = DEFAULT_POINT_BUDGET;\n  private _rendererSize: Vector2 = new Vector2();\n\n  maxNumNodesLoading: number = MAX_NUM_NODES_LOADING;\n  features = FEATURES;\n  lru = new LRU(this._pointBudget);\n\n  loadPointCloud(\n    url: string,\n    getUrl: GetUrlFn,\n    xhrRequest = (input: RequestInfo, init?: RequestInit) => fetch(input, init),\n  ): Promise<PointCloudOctree> {\n    return loadPOC(url, getUrl, xhrRequest).then(geometry => new PointCloudOctree(this, geometry));\n  }\n\n  updatePointClouds(\n    pointClouds: PointCloudOctree[],\n    camera: Camera,\n    renderer: WebGLRenderer,\n  ): IVisibilityUpdateResult {\n    const result = this.updateVisibility(pointClouds, camera, renderer);\n\n    for (let i = 0; i < pointClouds.length; i++) {\n      const pointCloud = pointClouds[i];\n      if (pointCloud.disposed) {\n        continue;\n      }\n\n      pointCloud.updateMaterial(\n        pointCloud.material,\n        pointCloud.visibleNodes,\n        camera as PerspectiveCamera,\n        renderer,\n      );\n      pointCloud.updateVisibleBounds();\n      pointCloud.updateBoundingBoxes();\n    }\n\n    this.lru.freeMemory();\n\n    return result;\n  }\n\n  get pointBudget(): number {\n    return this._pointBudget;\n  }\n\n  set pointBudget(value: number) {\n    if (value !== this._pointBudget) {\n      this._pointBudget = value;\n      this.lru.pointBudget = value;\n      this.lru.freeMemory();\n    }\n  }\n\n  private updateVisibility(\n    pointClouds: PointCloudOctree[],\n    camera: Camera,\n    renderer: WebGLRenderer,\n  ): IVisibilityUpdateResult {\n    let numVisiblePoints = 0;\n\n    const visibleNodes: PointCloudOctreeNode[] = [];\n    const unloadedGeometry: PointCloudOctreeGeometryNode[] = [];\n\n    // calculate object space frustum and cam pos and setup priority queue\n    const { frustums, cameraPositions, priorityQueue } = this.updateVisibilityStructures(\n      pointClouds,\n      camera,\n    );\n\n    let loadedToGPUThisFrame = 0;\n    let queueItem: QueueItem | undefined;\n\n    while ((queueItem = priorityQueue.pop()) !== undefined) {\n      let node = queueItem.node;\n\n      // If we will end up with too many points, we stop right away.\n      if (numVisiblePoints + node.numPoints > this.pointBudget) {\n        break;\n      }\n\n      const pointCloudIndex = queueItem.pointCloudIndex;\n      const pointCloud = pointClouds[pointCloudIndex];\n\n      const maxLevel = pointCloud.maxLevel !== undefined ? pointCloud.maxLevel : Infinity;\n\n      if (\n        node.level > maxLevel ||\n        !frustums[pointCloudIndex].intersectsBox(node.boundingBox) ||\n        this.shouldClip(pointCloud, node.boundingBox)\n      ) {\n        continue;\n      }\n\n      numVisiblePoints += node.numPoints;\n      pointCloud.numVisiblePoints += node.numPoints;\n\n      const parentNode = queueItem.parent;\n\n      if (isGeometryNode(node) && (!parentNode || isTreeNode(parentNode))) {\n        if (node.loaded && loadedToGPUThisFrame < MAX_LOADS_TO_GPU) {\n          node = pointCloud.toTreeNode(node, parentNode);\n          loadedToGPUThisFrame++;\n        } else {\n          unloadedGeometry.push(node);\n          pointCloud.visibleGeometry.push(node);\n        }\n      }\n\n      if (isTreeNode(node)) {\n        this.updateTreeNodeVisibility(pointCloud, node, visibleNodes);\n        pointCloud.visibleGeometry.push(node.geometryNode);\n      }\n\n      const halfHeight =\n        0.5 * renderer.getSize(this._rendererSize).height * renderer.getPixelRatio();\n\n      this.updateChildVisibility(\n        queueItem,\n        priorityQueue,\n        pointCloud,\n        node,\n        cameraPositions[pointCloudIndex],\n        camera,\n        halfHeight,\n      );\n    } // end priority queue loop\n\n    const numNodesToLoad = Math.min(this.maxNumNodesLoading, unloadedGeometry.length);\n    for (let i = 0; i < numNodesToLoad; i++) {\n      unloadedGeometry[i].load();\n    }\n\n    return {\n      visibleNodes: visibleNodes,\n      numVisiblePoints: numVisiblePoints,\n    };\n  }\n\n  private updateTreeNodeVisibility(\n    pointCloud: PointCloudOctree,\n    node: PointCloudOctreeNode,\n    visibleNodes: IPointCloudTreeNode[],\n  ): void {\n    this.lru.touch(node.geometryNode);\n\n    const sceneNode = node.sceneNode;\n    sceneNode.visible = true;\n    sceneNode.material = pointCloud.material;\n    sceneNode.updateMatrix();\n    sceneNode.matrixWorld.multiplyMatrices(pointCloud.matrixWorld, sceneNode.matrix);\n\n    visibleNodes.push(node);\n    pointCloud.visibleNodes.push(node);\n\n    this.updateBoundingBoxVisibility(pointCloud, node);\n  }\n\n  private updateChildVisibility(\n    queueItem: QueueItem,\n    priorityQueue: BinaryHeap<QueueItem>,\n    pointCloud: PointCloudOctree,\n    node: IPointCloudTreeNode,\n    cameraPosition: Vector3,\n    camera: Camera,\n    halfHeight: number,\n  ): void {\n    const children = node.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child === null) {\n        continue;\n      }\n\n      const sphere = child.boundingSphere;\n      const distance = sphere.center.distanceTo(cameraPosition);\n      const radius = sphere.radius;\n\n      let projectionFactor = 0.0;\n\n      if (camera.type === PERSPECTIVE_CAMERA) {\n        const perspective = camera as PerspectiveCamera;\n        const fov = (perspective.fov * Math.PI) / 180.0;\n        const slope = Math.tan(fov / 2.0);\n        projectionFactor = halfHeight / (slope * distance);\n      } else {\n        const orthographic = camera as OrthographicCamera;\n        projectionFactor = radius / orthographic.top;\n      }\n\n      const screenPixelRadius = radius * projectionFactor;\n\n      // Don't add the node if it'll be too small on the screen.\n      if (screenPixelRadius < pointCloud.minNodePixelSize) {\n        continue;\n      }\n\n      // Nodes which are larger will have priority in loading/displaying.\n      const weight = distance < radius ? Number.MAX_VALUE : screenPixelRadius + 1 / distance;\n\n      priorityQueue.push(new QueueItem(queueItem.pointCloudIndex, weight, child, node));\n    }\n  }\n\n  private updateBoundingBoxVisibility(\n    pointCloud: PointCloudOctree,\n    node: PointCloudOctreeNode,\n  ): void {\n    if (pointCloud.showBoundingBox && !node.boundingBoxNode) {\n      const boxHelper = new Box3Helper(node.boundingBox);\n      boxHelper.matrixAutoUpdate = false;\n      pointCloud.boundingBoxNodes.push(boxHelper);\n      node.boundingBoxNode = boxHelper;\n      node.boundingBoxNode.matrix.copy(pointCloud.matrixWorld);\n    } else if (pointCloud.showBoundingBox && node.boundingBoxNode) {\n      node.boundingBoxNode.visible = true;\n      node.boundingBoxNode.matrix.copy(pointCloud.matrixWorld);\n    } else if (!pointCloud.showBoundingBox && node.boundingBoxNode) {\n      node.boundingBoxNode.visible = false;\n    }\n  }\n\n  private shouldClip(pointCloud: PointCloudOctree, boundingBox: Box3): boolean {\n    const material = pointCloud.material;\n\n    if (material.numClipBoxes === 0 || material.clipMode !== ClipMode.CLIP_OUTSIDE) {\n      return false;\n    }\n\n    const box2 = boundingBox.clone();\n    pointCloud.updateMatrixWorld(true);\n    box2.applyMatrix4(pointCloud.matrixWorld);\n\n    const clipBoxes = material.clipBoxes;\n    for (let i = 0; i < clipBoxes.length; i++) {\n      const clipMatrixWorld = clipBoxes[i].matrix;\n      const clipBoxWorld = new Box3(\n        new Vector3(-0.5, -0.5, -0.5),\n        new Vector3(0.5, 0.5, 0.5),\n      ).applyMatrix4(clipMatrixWorld);\n      if (box2.intersectsBox(clipBoxWorld)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private updateVisibilityStructures = (() => {\n    const frustumMatrix = new Matrix4();\n    const inverseWorldMatrix = new Matrix4();\n    const cameraMatrix = new Matrix4();\n\n    return (\n      pointClouds: PointCloudOctree[],\n      camera: Camera,\n    ): {\n      frustums: Frustum[];\n      cameraPositions: Vector3[];\n      priorityQueue: BinaryHeap<QueueItem>;\n    } => {\n      const frustums: Frustum[] = [];\n      const cameraPositions = [];\n      const priorityQueue = new BinaryHeap<QueueItem>(x => 1 / x.weight);\n\n      for (let i = 0; i < pointClouds.length; i++) {\n        const pointCloud = pointClouds[i];\n\n        if (!pointCloud.initialized()) {\n          continue;\n        }\n\n        pointCloud.numVisiblePoints = 0;\n        pointCloud.visibleNodes = [];\n        pointCloud.visibleGeometry = [];\n\n        camera.updateMatrixWorld(false);\n\n        // Furstum in object space.\n        const inverseViewMatrix = camera.matrixWorldInverse;\n        const worldMatrix = pointCloud.matrixWorld;\n        frustumMatrix\n          .identity()\n          .multiply(camera.projectionMatrix)\n          .multiply(inverseViewMatrix)\n          .multiply(worldMatrix);\n        frustums.push(new Frustum().setFromMatrix(frustumMatrix));\n\n        // Camera position in object space\n        inverseWorldMatrix.getInverse(worldMatrix);\n        cameraMatrix\n          .identity()\n          .multiply(inverseWorldMatrix)\n          .multiply(camera.matrixWorld);\n        cameraPositions.push(new Vector3().setFromMatrixPosition(cameraMatrix));\n\n        if (pointCloud.visible && pointCloud.root !== null) {\n          const weight = Number.MAX_VALUE;\n          priorityQueue.push(new QueueItem(i, weight, pointCloud.root));\n        }\n\n        // Hide any previously visible nodes. We will later show only the needed ones.\n        if (isTreeNode(pointCloud.root)) {\n          pointCloud.hideDescendants(pointCloud.root.sceneNode);\n        }\n\n        for (const boundingBoxNode of pointCloud.boundingBoxNodes) {\n          boundingBoxNode.visible = false;\n        }\n      }\n\n      return { frustums, cameraPositions, priorityQueue };\n    };\n  })();\n}\n","export * from './materials';\nexport * from './point-attributes';\nexport * from './point-cloud-octree-geometry-node';\nexport * from './point-cloud-octree-geometry';\nexport * from './point-cloud-octree';\nexport * from './point-cloud-tree';\nexport * from './potree';\nexport * from './types';\nexport * from './version';\n"],"sourceRoot":""}